        -:    0:Source:src/k_ctds/parameter.c
        -:    0:Source is newer than graph
        -:    1:#include "include/push_warnings.h"
        -:    2:#include <Python.h>
        -:    3:#include "structmember.h"
        -:    4:#include "include/pop_warnings.h"
        -:    5:
        -:    6:#include <stddef.h>
        -:    7:#include <float.h>
        -:    8:#include <limits.h>
        -:    9:
        -:   10:#include "include/connection.h"
        -:   11:#include "include/macros.h"
        -:   12:#include "include/parameter.h"
        -:   13:#include "include/pyutils.h"
        -:   14:#include "include/tds.h"
        -:   15:#include "include/type.h"
        -:   16:
        -:   17:#ifdef __GNUC__
        -:   18:/* Ignore "ISO C90 does not support 'long long' [-Werror=long-long]". */
        -:   19:#  pragma GCC diagnostic ignored "-Wlong-long"
        -:   20:
        -:   21:#  ifndef __clang__
        -:   22:/* Ignore "ISO C90 does not support the 'll' gnu_printf length modifier [-Werror=format=]" */
        -:   23:#    pragma GCC diagnostic ignored "-Wformat="
        -:   24:#  endif /* ifndef __clang__ */
        -:   25:#endif /* ifdef __GNUC__ */
        -:   26:
        -:   27:#ifdef __clang__
        -:   28:# if PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION == 8
        -:   29:/* Ignore "'tp_print' has been explicitly marked deprecated here" */
        -:   30:#    pragma clang diagnostic push
        -:   31:#    pragma clang diagnostic ignored "-Wdeprecated-declarations"
        -:   32:#  endif /* if PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION == 8 */
        -:   33:#endif /* ifdef __clang__ */
        -:   34:
        -:   35:
        -:   36:#define TDS_TYPE_SIZE_FIXED (-1)
        -:   37:
        -:   38:struct Parameter
        -:   39:{
        -:   40:    PyObject_HEAD
        -:   41:
        -:   42:    /*
        -:   43:        Note: If the first member changes, the creation code must be updated to
        -:   44:        properly initialize members to zero.
        -:   45:    */
        -:   46:
        -:   47:    /* The underlying Python object this parameter wraps. */
        -:   48:    PyObject* value;
        -:   49:
        -:   50:    /*
        -:   51:        The underlying Python source object for the parameter's data.
        -:   52:        This is only set when the source data has been translated in some way
        -:   53:        from the original object referred to by `value`. This reference
        -:   54:        merely exists to ensure any data owned by the `source` object can
        -:   55:        be safely passed and used by the DB-lib APIs.
        -:   56:    */
        -:   57:    PyObject* source;
        -:   58:
        -:   59:    /*
        -:   60:        The type of this parameter. This may be inferred from the Python type
        -:   61:        or explicitly specified via one of the Sql* types.
        -:   62:    */
        -:   63:    enum TdsType tdstype;
        -:   64:
        -:   65:    /*
        -:   66:        The size of this parameter. For fixed length values, this is -1. For
        -:   67:        NULL values, this is 0.
        -:   68:    */
        -:   69:    DBINT tdstypesize;
        -:   70:
        -:   71:    /*
        -:   72:        A buffer containing the input data for dblib to read from.
        -:   73:    */
        -:   74:    union {
        -:   75:        BYTE byte;
        -:   76:        DBINT dbint;
        -:   77:        DBBIGINT dbbigint;
        -:   78:        DBDECIMAL dbdecimal;
        -:   79:#if defined(CTDS_HAVE_TDS73_SUPPORT)
        -:   80:        DBDATETIMEALL dbdatetime;
        -:   81:#else /* if defined(CTDS_HAVE_TDS73_SUPPORT) */
        -:   82:        DBDATETIME dbdatetime;
        -:   83:#endif /* else if defined(CTDS_HAVE_TDS73_SUPPORT) */
        -:   84:        DBFLT8 dbflt8;
        -:   85:    } buffer;
        -:   86:
        -:   87:    const void* input;
        -:   88:
        -:   89:    /* The size of `input`, in bytes. */
        -:   90:    size_t ninput;
        -:   91:
        -:   92:    /*
        -:   93:        A buffer for the output parameter data. If this value is NULL, the
        -:   94:        parameter is not an output parameter.
        -:   95:    */
        -:   96:    void* output;
        -:   97:
        -:   98:    /* The size of `output`, in bytes. */
        -:   99:    size_t noutput;
        -:  100:
        -:  101:    bool isoutput;
        -:  102:};
        -:  103:
function Parameter_dealloc called 0 returned 0% blocks executed 0%
    #####:  104:static void Parameter_dealloc(PyObject* self)
        -:  105:{
    #####:  106:    struct Parameter* parameter = (struct Parameter*)self;
    #####:  107:    Py_XDECREF(parameter->value);
call    0 never executed
    #####:  108:    Py_XDECREF(parameter->source);
call    0 never executed
    #####:  109:    tds_mem_free(parameter->output);
    #####:  110:    PyObject_Del(self);
call    0 never executed
    #####:  111:}
        -:  112:
function Parameter_new called 0 returned 0% blocks executed 0%
    #####:  113:static PyObject* Parameter_new(PyTypeObject* type, PyObject* args, PyObject* kwargs)
        -:  114:{
    #####:  115:    PyObject* value;
    #####:  116:    static char* s_kwlist[] =
        -:  117:    {
        -:  118:        "value",
        -:  119:        "output",
        -:  120:        NULL
        -:  121:    };
    #####:  122:    PyObject* output = Py_False;
    #####:  123:    if (!PyArg_ParseTupleAndKeywords(args,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  124:                                     kwargs, "O|O!",
        -:  125:                                     s_kwlist,
        -:  126:                                     &value,
        -:  127:                                     &PyBool_Type,
        -:  128:                                     &output))
        -:  129:    {
        -:  130:        return NULL;
        -:  131:    }
        -:  132:
    #####:  133:    return (PyObject*)Parameter_create(value, (bool)(Py_True == output));
call    0 never executed
    #####:  134:    UNUSED(type);
        -:  135:}
        -:  136:
function Parameter_repr called 0 returned 0% blocks executed 0%
    #####:  137:static PyObject* Parameter_repr(PyObject* self)
        -:  138:{
    #####:  139:    const struct Parameter* parameter = (const struct Parameter*)self;
    #####:  140:    PyObject* repr = NULL;
        -:  141:
        -:  142:#if PY_MAJOR_VERSION < 3
        -:  143:    /*
        -:  144:        Python2.6's implementation of `PyUnicode_FromFormat` is buggy and
        -:  145:        will crash when the '%R' format specifier is used. Additionally
        -:  146:        a conversion to the `str` type is required. Avoid all this in Python2.
        -:  147:    */
        -:  148:    PyObject* value = PyObject_Repr(parameter->value);
        -:  149:    if (value)
        -:  150:    {
        -:  151:        repr = PyString_FromFormat(
        -:  152:            (parameter->isoutput) ? "%s(%s, output=True)" : "%s(%s)",
        -:  153:            Py_TYPE(self)->tp_name,
        -:  154:            PyString_AS_STRING(value)
        -:  155:        );
        -:  156:        Py_DECREF(value);
        -:  157:    }
        -:  158:#else /* if PY_MAJOR_VERSION < 3 */
    #####:  159:    repr = PyUnicode_FromFormat(
call    0 never executed
    #####:  160:        (parameter->isoutput) ? "%s(%R, output=True)" : "%s(%R)",
    #####:  161:        Py_TYPE(self)->tp_name,
branch  0 never executed
branch  1 never executed
    #####:  162:        parameter->value
branch  0 never executed
branch  1 never executed
        -:  163:    );
        -:  164:#endif /* else if PY_MAJOR_VERSION < 3 */
    #####:  165:    return repr;
        -:  166:}
        -:  167:
        -:  168:PyTypeObject ParameterType; /* forward declaration */
        -:  169:
function Parameter_richcompare called 0 returned 0% blocks executed 0%
    #####:  170:static PyObject* Parameter_richcompare(PyObject* self, PyObject* other, int op)
        -:  171:{
    #####:  172:    if (PyObject_TypeCheck(other, &ParameterType))
branch  0 never executed
branch  1 never executed
        -:  173:    {
    #####:  174:        other = ((const struct Parameter*)other)->value;
        -:  175:    }
        -:  176:
    #####:  177:    return PyObject_RichCompare(((const struct Parameter*)self)->value, other, op);
call    0 never executed
        -:  178:}
        -:  179:
        -:  180:static PyMemberDef s_Parameter_members[] = {
        -:  181:    /* name, type, offset, flags, doc */
        -:  182:    { (char*)"value",   T_OBJECT, offsetof(struct Parameter, value), READONLY, NULL },
        -:  183:    { NULL,             0,        0,                                 0,        NULL }
        -:  184:};
        -:  185:
        -:  186:static const char s_tds_Parameter_doc[] =
        -:  187:    "Parameter(value, output=False)\n"
        -:  188:    "\n"
        -:  189:    "Explicitly define a parameter for :py:meth:`.callproc`,\n"
        -:  190:    ":py:meth:`.execute`, or :py:meth:`.executemany`. This is necessary\n"
        -:  191:    "to indicate whether a parameter is *SQL* `OUTPUT` or `INPUT/OUTPUT`\n"
        -:  192:    "parameter.\n"
        -:  193:    "\n"
        -:  194:    ":param object value: The parameter's value.\n"
        -:  195:    ":param bool output: Is the parameter an output parameter.\n";
        -:  196:#pragma GCC diagnostic push
        -:  197:#pragma GCC diagnostic ignored "-Wmissing-field-initializers"
        -:  198:PyTypeObject ParameterType = {
        -:  199:    PyVarObject_HEAD_INIT(NULL, 0)
        -:  200:    "k_ctds.Parameter",             /* tp_name */
        -:  201:    sizeof(struct Parameter),     /* tp_basicsize */
        -:  202:    0,                            /* tp_itemsize */
        -:  203:    Parameter_dealloc,            /* tp_dealloc */
        -:  204:#if PY_VERSION_HEX >= 0x03080000
        -:  205:    0,                            /* tp_vectorcall_offset */
        -:  206:#else
        -:  207:    NULL,                         /* tp_print */
        -:  208:#endif /* if PY_VERSION_HEX >= 0x03080000 */
        -:  209:    NULL,                         /* tp_getattr */
        -:  210:    NULL,                         /* tp_setattr */
        -:  211:    NULL,                         /* tp_reserved */
        -:  212:    Parameter_repr,               /* tp_repr */
        -:  213:    NULL,                         /* tp_as_number */
        -:  214:    NULL,                         /* tp_as_sequence */
        -:  215:    NULL,                         /* tp_as_mapping */
        -:  216:    NULL,                         /* tp_hash */
        -:  217:    NULL,                         /* tp_call */
        -:  218:    NULL,                         /* tp_str */
        -:  219:    NULL,                         /* tp_getattro */
        -:  220:    NULL,                         /* tp_setattro */
        -:  221:    NULL,                         /* tp_as_buffer */
        -:  222:    Py_TPFLAGS_DEFAULT,           /* tp_flags */
        -:  223:    s_tds_Parameter_doc,          /* tp_doc */
        -:  224:    NULL,                         /* tp_traverse */
        -:  225:    NULL,                         /* tp_clear */
        -:  226:    Parameter_richcompare,        /* tp_richcompare */
        -:  227:    0,                            /* tp_weaklistoffset */
        -:  228:    NULL,                         /* tp_iter */
        -:  229:    NULL,                         /* tp_iternext */
        -:  230:    NULL,                         /* tp_methods */
        -:  231:    s_Parameter_members,          /* tp_members */
        -:  232:    NULL,                         /* tp_getset */
        -:  233:    NULL,                         /* tp_base */
        -:  234:    NULL,                         /* tp_dict */
        -:  235:    NULL,                         /* tp_descr_get */
        -:  236:    NULL,                         /* tp_descr_set */
        -:  237:    0,                            /* tp_dictoffset */
        -:  238:    NULL,                         /* tp_init */
        -:  239:    NULL,                         /* tp_alloc */
        -:  240:    Parameter_new,                /* tp_new */
        -:  241:    NULL,                         /* tp_free */
        -:  242:    NULL,                         /* tp_is_gc */
        -:  243:    NULL,                         /* tp_bases */
        -:  244:    NULL,                         /* tp_mro */
        -:  245:    NULL,                         /* tp_cache */
        -:  246:    NULL,                         /* tp_subclasses */
        -:  247:    NULL,                         /* tp_weaklist */
        -:  248:    NULL,                         /* tp_del */
        -:  249:    0,                            /* tp_version_tag */
        -:  250:#if PY_VERSION_HEX >= 0x03040000
        -:  251:    NULL,                         /* tp_finalize */
        -:  252:#endif /* if PY_VERSION_HEX >= 0x03040000 */
        -:  253:#if PY_VERSION_HEX >= 0x03080000
        -:  254:    NULL,                         /* tp_vectorcall */
        -:  255:#  if PY_VERSION_HEX < 0x03090000
        -:  256:    NULL,                         /* tp_print */
        -:  257:#  endif /* if PY_VERSION_HEX < 0x03090000 */
        -:  258:#endif /* if PY_VERSION_HEX >= 0x03080000 */
        -:  259:};
        -:  260:#pragma GCC diagnostic pop
        -:  261:
        -:  262:/*
        -:  263:    Convert a python object to a parameter for use in a SQL statement.
        -:  264:
        -:  265:    An appropriate Python error is set on failure.
        -:  266:
        -:  267:    @param parameter [in] The parameter to bind the Python object to.
        -:  268:    @param value [in] The Python object to bind.
        -:  269:
        -:  270:    @return -1 on error, 0 on success.
        -:  271:*/
function Parameter_convert_to_tds called 0 returned 0% blocks executed 0%
    #####:  272:static int Parameter_convert_to_tds(struct Parameter* parameter, DBPROCESS* dbproc)
        -:  273:{
    #####:  274:    assert(parameter->value);
        -:  275:
    #####:  276:    if (SqlType_Check(parameter->value))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  277:    {
        -:  278:        /* Explicitly specified a SQL type. */
    #####:  279:        struct SqlType* sqltype = (struct SqlType*)parameter->value;
        -:  280:
    #####:  281:        parameter->input = sqltype->data;
    #####:  282:        parameter->ninput = sqltype->ndata;
    #####:  283:        parameter->tdstypesize = (DBINT)sqltype->size;
    #####:  284:        parameter->tdstype = sqltype->tdstype;
        -:  285:
    #####:  286:        if (TDSDATE == sqltype->tdstype)
branch  0 never executed
branch  1 never executed
        -:  287:        {
        -:  288:            /* FreeTDS doesn't support passing TDSDATE properly. Fallback to DATETIME. */
    #####:  289:            parameter->tdstype = TDSDATETIME;
        -:  290:        }
        -:  291:    }
        -:  292:    else
        -:  293:    {
        -:  294:        /* Infer the SQL type from the Python type. */
        -:  295:
        -:  296:        /* Default to a fixed size TDS type. */
    #####:  297:        parameter->tdstypesize = -1;
        -:  298:
    #####:  299:        do
    #####:  300:        {
    #####:  301:            if (PyUnicode_Check(parameter->value))
branch  0 never executed
branch  1 never executed
        -:  302:            {
    #####:  303:                size_t nchars; /* number of unicode characters in the string */
        -:  304:
    #####:  305:                const char* utf8bytes;
        -:  306:
    #####:  307:                Py_XDECREF(parameter->source);
call    0 never executed
    #####:  308:                parameter->source = encode_for_dblib(parameter->value,
call    0 never executed
        -:  309:                                                     &utf8bytes,
        -:  310:                                                     &parameter->ninput,
        -:  311:                                                     &nchars);
    #####:  312:                if (!parameter->source)
branch  0 never executed
branch  1 never executed
        -:  313:                {
        -:  314:                    break;
        -:  315:                }
    #####:  316:                parameter->input = (const void*)utf8bytes;
        -:  317:
        -:  318:                /*
        -:  319:                    FreeTDS does not support passing *VARCHAR(MAX) types.
        -:  320:                    Use the *TEXT types instead.
        -:  321:                */
        -:  322:
        -:  323:                /*
        -:  324:                    FreeTDS doesn't have good support for NCHAR types prior
        -:  325:                    to 0.95. Fallback to VARCHAR with somewhat crippled
        -:  326:                    functionality.
        -:  327:                */
        -:  328:
        -:  329:#if defined(CTDS_USE_NCHARS)
    #####:  330:                parameter->tdstype = (nchars > TDS_NCHAR_MAX_SIZE) ? TDSNTEXT : TDSNVARCHAR;
branch  0 never executed
branch  1 never executed
        -:  331:#else /* if defined(CTDS_USE_NCHARS) */
        -:  332:                parameter->tdstype = (nchars > TDS_CHAR_MAX_SIZE) ? TDSTEXT : TDSVARCHAR;
        -:  333:#endif /* else if defined(CTDS_USE_NCHARS) */
    #####:  334:                parameter->tdstypesize = (DBINT)nchars;
        -:  335:            }
        -:  336:            /* Check for bools prior to integers, which are treated as a boolean type by Python. */
    #####:  337:            else if (PyBool_Check(parameter->value))
branch  0 never executed
branch  1 never executed
        -:  338:            {
    #####:  339:                parameter->buffer.byte = (BYTE)(Py_True == parameter->value);
        -:  340:
    #####:  341:                parameter->input = (const void*)&parameter->buffer;
    #####:  342:                parameter->ninput = sizeof(parameter->buffer.byte);
        -:  343:
    #####:  344:                parameter->tdstype = TDSBITN;
    #####:  345:                parameter->tdstypesize = (DBINT)parameter->ninput;
        -:  346:            }
    #####:  347:            else if (
        -:  348:#if PY_MAJOR_VERSION < 3
        -:  349:                     PyInt_Check(parameter->value) ||
        -:  350:#endif /* if PY_MAJOR_VERSION < 3 */
    #####:  351:                     PyLong_Check(parameter->value)
branch  0 never executed
branch  1 never executed
        -:  352:                     )
        -:  353:            {
    #####:  354:                PY_LONG_LONG ll = 0;
        -:  355:#if PY_MAJOR_VERSION < 3
        -:  356:                if (PyInt_Check(parameter->value))
        -:  357:                {
        -:  358:                    ll = PyInt_AsLong(parameter->value);
        -:  359:                }
        -:  360:                else
        -:  361:#endif /* if PY_MAJOR_VERSION < 3 */
        -:  362:                {
        -:  363:                    /* This will raise an expected OverflowError on overflow. */
    #####:  364:                    ll = PyLong_AsLongLong(parameter->value);
call    0 never executed
        -:  365:                }
        -:  366:
    #####:  367:                if (PyErr_Occurred())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  368:                {
        -:  369:                    break;
        -:  370:                }
        -:  371:
    #####:  372:                if (INT32_MIN <= ll && ll <= INT32_MAX)
branch  0 never executed
branch  1 never executed
        -:  373:                {
    #####:  374:                    parameter->buffer.dbint = (DBINT)ll;
    #####:  375:                    parameter->ninput = sizeof(parameter->buffer.dbint);
        -:  376:
        -:  377:                    /* TINYINT is unsigned. */
    #####:  378:                    if (0 <= ll && ll <= 255)
branch  0 never executed
branch  1 never executed
        -:  379:                    {
    #####:  380:                        parameter->tdstype = TDSTINYINT;
        -:  381:                    }
    #####:  382:                    else if (INT16_MIN <= ll && ll <= INT16_MAX)
branch  0 never executed
branch  1 never executed
        -:  383:                    {
    #####:  384:                        parameter->tdstype = TDSSMALLINT;
        -:  385:                    }
        -:  386:                    else
        -:  387:                    {
    #####:  388:                       parameter->tdstype = TDSINT;
        -:  389:                    }
        -:  390:                }
        -:  391:                else
        -:  392:                {
    #####:  393:                    parameter->buffer.dbbigint = (DBBIGINT)ll;
    #####:  394:                    parameter->ninput = sizeof(parameter->buffer.dbbigint);
        -:  395:
    #####:  396:                    parameter->tdstype = TDSBIGINT;
        -:  397:                }
        -:  398:
    #####:  399:                parameter->input = (const void*)&parameter->buffer;
        -:  400:            }
    #####:  401:            else if (PyBytes_Check(parameter->value) || PyByteArray_Check(parameter->value))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  402:            {
    #####:  403:                if (PyBytes_Check(parameter->value))
branch  0 never executed
branch  1 never executed
        -:  404:                {
    #####:  405:                    char* data;
    #####:  406:                    Py_ssize_t size;
    #####:  407:                    (void)PyBytes_AsStringAndSize(parameter->value, &data, &size);
call    0 never executed
    #####:  408:                    parameter->input = (const void*)data;
    #####:  409:                    parameter->ninput = (size_t)size;
        -:  410:                }
        -:  411:                else
        -:  412:                {
    #####:  413:                    parameter->input = (const void*)PyByteArray_AS_STRING(parameter->value);
branch  0 never executed
branch  1 never executed
    #####:  414:                    parameter->ninput = (size_t)PyByteArray_GET_SIZE(parameter->value);
        -:  415:                }
        -:  416:
        -:  417:                /*
        -:  418:                    FreeTDS 0.95.74 does not support passing VARBINARY types larger
        -:  419:                    than 8000 characters. Use the IMAGE type instead.
        -:  420:                */
    #####:  421:                parameter->tdstype = (parameter->ninput > 8000) ? TDSIMAGE : TDSVARBINARY;
branch  0 never executed
branch  1 never executed
        -:  422:
        -:  423:                /* Non-NULL values must have a non-zero length.  */
    #####:  424:                parameter->tdstypesize = (DBINT)parameter->ninput;
        -:  425:            }
    #####:  426:            else if (PyFloat_Check(parameter->value))
branch  0 never executed
branch  1 never executed
        -:  427:            {
    #####:  428:                parameter->buffer.dbflt8 = (DBFLT8)PyFloat_AS_DOUBLE(parameter->value);
        -:  429:
    #####:  430:                parameter->input = (const void*)&parameter->buffer;
    #####:  431:                parameter->ninput = sizeof(parameter->buffer.dbflt8);
        -:  432:
    #####:  433:                parameter->tdstype = TDSFLOAT;
        -:  434:            }
    #####:  435:            else if (PyDecimal_Check(parameter->value))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  436:            {
    #####:  437:                PyObject* ostr = NULL;
        -:  438:
    #####:  439:                do
    #####:  440:                {
    #####:  441:                    Py_ssize_t nutf8;
    #####:  442:                    const char* str;
        -:  443:
    #####:  444:                    ostr = PyDecimal_ToString(parameter->value);
call    0 never executed
    #####:  445:                    if (!ostr)
branch  0 never executed
branch  1 never executed
        -:  446:                    {
        -:  447:                        break;
        -:  448:                    }
        -:  449:
        -:  450:#if PY_MAJOR_VERSION < 3
        -:  451:                    str = PyString_AS_STRING(ostr);
        -:  452:                    nutf8 = PyString_GET_SIZE(ostr);
        -:  453:#else /* if PY_MAJOR_VERSION < 3 */
    #####:  454:                    str = PyUnicode_AsUTF8AndSize(ostr, &nutf8);
call    0 never executed
        -:  455:#endif /* else if PY_MAJOR_VERSION < 3 */
        -:  456:
    #####:  457:                    do
    #####:  458:                    {
    #####:  459:                        DBTYPEINFO dbtypeinfo;
    #####:  460:                        DBINT size;
        -:  461:
        -:  462:                        /*
        -:  463:                            Determine the precision and scale based on the integer
        -:  464:                            and fractional part lengths. Ideally these would be
        -:  465:                            retrieved directly from the current decimal.Context,
        -:  466:                            but this is not feasible. Assume the desired scale
        -:  467:                            and precision are reflected in the string
        -:  468:                            representation.
        -:  469:                        */
    #####:  470:                        const char* point = strchr(str, '.');
    #####:  471:                        bool negative = ('-' == *str);
    #####:  472:                        size_t integer =
    #####:  473:                            (size_t)((point) ? (point - str) : nutf8) -
branch  0 never executed
branch  1 never executed
        -:  474:                            /* Ignore negative sign. */
    #####:  475:                            ((negative) ? 1 : 0);
branch  0 never executed
branch  1 never executed
    #####:  476:                        size_t fractional = ((size_t)nutf8 - ((point) ? 1 : 0) - ((negative) ? 1 : 0)) - integer;
branch  0 never executed
branch  1 never executed
        -:  477:
    #####:  478:                        if (integer > DECIMAL_MAX_PRECISION)
branch  0 never executed
branch  1 never executed
        -:  479:                        {
    #####:  480:                            PyErr_Format(PyExc_tds_DataError, "Decimal('%s') out of range", str);
    #####:  481:                            break;
call    0 never executed
        -:  482:                        }
    #####:  483:                        if (DECIMAL_MAX_PRECISION < (integer + fractional))
branch  0 never executed
branch  1 never executed
        -:  484:                        {
    #####:  485:                            static const char s_fmt[] =
        -:  486:                                "Decimal('%s') exceeds SQL DECIMAL precision; truncating";
    #####:  487:                            char buffer[ARRAYSIZE(s_fmt) + 100];
    #####:  488:                            (void)PyOS_snprintf(buffer, ARRAYSIZE(buffer), s_fmt, str);
call    0 never executed
    #####:  489:                            buffer[ARRAYSIZE(buffer) - 1] = '\0';
    #####:  490:                            if (0 != PyErr_WarnEx(PyExc_Warning, buffer, 1))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  491:                            {
        -:  492:                                break;
        -:  493:                            }
        -:  494:
    #####:  495:                            dbtypeinfo.precision = DECIMAL_MAX_PRECISION;
        -:  496:                        }
        -:  497:                        else
        -:  498:                        {
    #####:  499:                            dbtypeinfo.precision = (DBINT)(integer + fractional);
        -:  500:                        }
        -:  501:
    #####:  502:                        dbtypeinfo.scale = (DBINT)MIN(fractional, DECIMAL_MAX_PRECISION - integer);
branch  0 never executed
branch  1 never executed
        -:  503:
    #####:  504:                        size = dbconvert_ps(dbproc,
        -:  505:                                            TDSCHAR,
        -:  506:                                            (BYTE*)str,
        -:  507:                                            (DBINT)nutf8,
        -:  508:                                            TDSDECIMAL,
    #####:  509:                                            (BYTE*)&parameter->buffer.dbdecimal,
call    0 never executed
        -:  510:                                            sizeof(parameter->buffer.dbdecimal),
        -:  511:                                            &dbtypeinfo);
    #####:  512:                        if (-1 == size)
branch  0 never executed
branch  1 never executed
        -:  513:                        {
    #####:  514:                            PyErr_Format(PyExc_tds_InterfaceError, "failed to convert Decimal('%s')", str);
    #####:  515:                            break;
call    0 never executed
        -:  516:                        }
        -:  517:                        else
        -:  518:                        {
    #####:  519:                            parameter->ninput = (size_t)size;
    #####:  520:                            parameter->tdstype = TDSDECIMAL;
    #####:  521:                            parameter->input = (const void*)&parameter->buffer;
        -:  522:                        }
        -:  523:                    } while (0);
        -:  524:                } while (0);
        -:  525:
    #####:  526:                Py_XDECREF(ostr);
call    0 never executed
        -:  527:
    #####:  528:                if (PyErr_Occurred()) break;
call    0 never executed
        -:  529:            }
    #####:  530:            else if (PyDate_Check_(parameter->value) || PyTime_Check_(parameter->value))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  531:            {
    #####:  532:                int ninput = datetime_to_sql(dbproc,
        -:  533:                                             parameter->value,
        -:  534:                                             &parameter->tdstype,
    #####:  535:                                             &parameter->buffer.dbdatetime,
call    0 never executed
        -:  536:                                             sizeof(parameter->buffer.dbdatetime));
    #####:  537:                if (-1 == ninput)
branch  0 never executed
branch  1 never executed
        -:  538:                {
    #####:  539:                    PyErr_Format(PyExc_tds_InterfaceError, "failed to convert datetime");
    #####:  540:                    break;
call    0 never executed
        -:  541:                }
        -:  542:
    #####:  543:                parameter->ninput = (size_t)ninput;
    #####:  544:                parameter->input = (const void*)&parameter->buffer;
        -:  545:            }
    #####:  546:            else if (PyUuid_Check(parameter->value))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  547:            {
        -:  548:                /*
        -:  549:                    FreeTDS doesn't support passing the raw bytes of the GUID, so pass
        -:  550:                    it as CHAR.
        -:  551:                */
    #####:  552:                PyObject* uuidstr = PyObject_Str(parameter->value);
call    0 never executed
    #####:  553:                if (uuidstr)
branch  0 never executed
branch  1 never executed
        -:  554:                {
        -:  555:#if PY_MAJOR_VERSION >= 3
    #####:  556:                    Py_ssize_t size;
        -:  557:#endif /* if PY_MAJOR_VERSION >= 3 */
    #####:  558:                    Py_XDECREF(parameter->source);
call    0 never executed
    #####:  559:                    parameter->source = uuidstr; /* claim reference */
        -:  560:#if PY_MAJOR_VERSION < 3
        -:  561:                    parameter->input = (const void*)PyString_AS_STRING(uuidstr);
        -:  562:                    parameter->ninput = (size_t)PyString_GET_SIZE(uuidstr);
        -:  563:#else /* if PY_MAJOR_VERSION < 3 */
    #####:  564:                    parameter->input = (const void*)PyUnicode_AsUTF8AndSize(uuidstr, &size);
call    0 never executed
    #####:  565:                    parameter->ninput = (size_t)size;
        -:  566:#endif /* else if PY_MAJOR_VERSION < 3 */
        -:  567:
    #####:  568:                    assert(36 == parameter->ninput);
        -:  569:
    #####:  570:                    parameter->tdstype = TDSCHAR;
    #####:  571:                    parameter->tdstypesize = (DBINT)parameter->ninput;
        -:  572:                }
        -:  573:            }
    #####:  574:            else if (Py_None == parameter->value)
branch  0 never executed
branch  1 never executed
        -:  575:            {
        -:  576:                /*
        -:  577:                    Default to VARCHAR for an untyped None value.
        -:  578:                    Note: This will *not* work with BINARY types.
        -:  579:
        -:  580:                    Ideally this would be the NULL type (0x1f), but it isn't supported by FreeTDS.
        -:  581:                */
    #####:  582:                parameter->input = NULL;
    #####:  583:                parameter->ninput = 0;
        -:  584:
    #####:  585:                parameter->tdstype = TDSVARCHAR;
    #####:  586:                parameter->tdstypesize = (DBINT)parameter->ninput;
        -:  587:            }
        -:  588:            else
        -:  589:            {
        -:  590:                /* An unsupported type. */
    #####:  591:                PyObject* typestr = PyObject_Str((PyObject*)parameter->value->ob_type);
call    0 never executed
    #####:  592:                if (typestr)
branch  0 never executed
branch  1 never executed
        -:  593:                {
    #####:  594:                    PyErr_Format(PyExc_tds_InterfaceError,
call    0 never executed
call    1 never executed
        -:  595:                                 "could not implicitly convert Python type \"%s\" to SQL",
        -:  596:#if PY_MAJOR_VERSION < 3
        -:  597:                                 PyString_AS_STRING(typestr)
        -:  598:#else /* if PY_MAJOR_VERSION < 3 */
        -:  599:                                 PyUnicode_AsUTF8(typestr)
        -:  600:#endif /* else if PY_MAJOR_VERSION < 3 */
        -:  601:                                 );
    #####:  602:                    Py_DECREF(typestr);
branch  0 never executed
branch  1 never executed
        -:  603:                }
        -:  604:            }
        -:  605:        } while (0);
        -:  606:    }
        -:  607:
    #####:  608:    return (PyErr_Occurred()) ? -1 : 0;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  609:}
        -:  610:
function Parameter_bind called 0 returned 0% blocks executed 0%
    #####:  611:int Parameter_bind(struct Parameter* parameter, DBPROCESS* dbproc)
        -:  612:{
    #####:  613:    do
    #####:  614:    {
    #####:  615:        if (0 != Parameter_convert_to_tds(parameter, dbproc))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  616:        {
        -:  617:            break;
        -:  618:        }
        -:  619:
    #####:  620:        if (parameter->isoutput)
branch  0 never executed
branch  1 never executed
        -:  621:        {
        -:  622:            /*
        -:  623:                Use the type size for variable-length parameters.
        -:  624:                Determine the fixed size from the type.
        -:  625:            */
    #####:  626:            bool fixed = (-1 == parameter->tdstypesize);
    #####:  627:            if (fixed)
branch  0 never executed
branch  1 never executed
        -:  628:            {
    #####:  629:                switch (parameter->tdstype)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -:  630:                {
    #####:  631:                    case TDSBIT:
        -:  632:                    case TDSBITN:
        -:  633:                    case TDSINTN:
        -:  634:                    case TDSTINYINT:
        -:  635:                    case TDSSMALLINT:
        -:  636:                    case TDSINT:
        -:  637:                    {
    #####:  638:                        parameter->noutput = sizeof(DBINT);
    #####:  639:                        break;
        -:  640:                    }
    #####:  641:                    case TDSBIGINT:
        -:  642:                    {
    #####:  643:                        parameter->noutput = sizeof(DBBIGINT);
    #####:  644:                        break;
        -:  645:                    }
    #####:  646:                    case TDSFLOAT:
        -:  647:                    case TDSFLOATN:
        -:  648:                    case TDSREAL:
        -:  649:                    {
    #####:  650:                        parameter->noutput = sizeof(DBFLT8);
    #####:  651:                        break;
        -:  652:                    }
    #####:  653:                    case TDSDATETIME:
        -:  654:                    case TDSSMALLDATETIME:
        -:  655:                    case TDSDATETIMEN:
        -:  656:                    case TDSDATE:
        -:  657:                    case TDSTIME:
        -:  658:                    case TDSDATETIME2:
        -:  659:                    case TDSDATETIMEOFFSET:
        -:  660:                    {
        -:  661:#if defined(CTDS_HAVE_TDS73_SUPPORT)
    #####:  662:                        parameter->noutput = sizeof(DBDATETIMEALL);
        -:  663:#else /* if defined(CTDS_HAVE_TDS73_SUPPORT) */
        -:  664:                        parameter->noutput = sizeof(DBDATETIME);
        -:  665:#endif /* else if defined(CTDS_HAVE_TDS73_SUPPORT) */
    #####:  666:                        break;
        -:  667:                    }
    #####:  668:                    case TDSSMALLMONEY:
        -:  669:                    case TDSMONEY:
        -:  670:                    case TDSMONEYN:
        -:  671:                    case TDSNUMERIC:
        -:  672:                    case TDSDECIMAL:
        -:  673:                    {
    #####:  674:                        parameter->noutput = sizeof(DBDECIMAL);
    #####:  675:                        break;
        -:  676:                    }
    #####:  677:                    case TDSGUID:
        -:  678:                    {
    #####:  679:                        parameter->noutput = 16;
    #####:  680:                        break;
        -:  681:                    }
    #####:  682:                    default:
        -:  683:                    {
    #####:  684:                        parameter->noutput = 0;
    #####:  685:                        break;
        -:  686:                    }
        -:  687:                }
        -:  688:            }
        -:  689:            else
        -:  690:            {
    #####:  691:                parameter->noutput = (size_t)parameter->tdstypesize;
        -:  692:            }
        -:  693:
    #####:  694:            tds_mem_free(parameter->output);
    #####:  695:            parameter->output = tds_mem_malloc(parameter->noutput);
    #####:  696:            if (!parameter->output)
branch  0 never executed
branch  1 never executed
        -:  697:            {
    #####:  698:                PyErr_NoMemory();
    #####:  699:                break;
call    0 never executed
        -:  700:            }
        -:  701:
    #####:  702:            memset(parameter->output, 0, parameter->noutput);
        -:  703:
    #####:  704:            memcpy(parameter->output,
        -:  705:                   parameter->input,
    #####:  706:                   MIN(parameter->ninput, parameter->noutput));
        -:  707:        }
        -:  708:    }
        -:  709:    while (0);
        -:  710:
    #####:  711:    return PyErr_Occurred() ? -1 : 0;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  712:}
        -:  713:
function Parameter_create called 0 returned 0% blocks executed 0%
    #####:  714:struct Parameter* Parameter_create(PyObject* value, bool output)
        -:  715:{
    #####:  716:    struct Parameter* parameter = PyObject_New(struct Parameter, &ParameterType);
call    0 never executed
    #####:  717:    if (NULL != parameter)
branch  0 never executed
branch  1 never executed
        -:  718:    {
    #####:  719:        memset((((char*)parameter) + offsetof(struct Parameter, value)),
        -:  720:               0,
        -:  721:               (sizeof(struct Parameter) - offsetof(struct Parameter, value)));
    #####:  722:        parameter->isoutput = output;
        -:  723:
    #####:  724:        parameter->value = value;
    #####:  725:        Py_INCREF(parameter->value);
branch  0 never executed
branch  1 never executed
        -:  726:    }
        -:  727:    else
        -:  728:    {
    #####:  729:        PyErr_NoMemory();
call    0 never executed
        -:  730:    }
        -:  731:
    #####:  732:    return parameter;
        -:  733:}
        -:  734:
function Parameter_dbrpcparam called 0 returned 0% blocks executed 0%
    #####:  735:RETCODE Parameter_dbrpcparam(struct Parameter* parameter, DBPROCESS* dbproc, const char* paramname)
        -:  736:{
    #####:  737:    return dbrpcparam(dbproc,
        -:  738:                      paramname,
        -:  739:                      (parameter->output) ? DBRPCRETURN : 0,
    #####:  740:                      parameter->tdstype,
call    0 never executed
        -:  741:                      (parameter->output) ? parameter->tdstypesize : -1,
    #####:  742:                      (DBINT)parameter->ninput,
branch  0 never executed
branch  1 never executed
    #####:  743:                      (BYTE*)((parameter->output) ? parameter->output : parameter->input));
branch  0 never executed
branch  1 never executed
        -:  744:}
        -:  745:
function Parameter_bcp_bind called 0 returned 0% blocks executed 0%
    #####:  746:RETCODE Parameter_bcp_bind(struct Parameter* parameter, DBPROCESS* dbproc, size_t column)
        -:  747:{
        -:  748:    /*
        -:  749:        FreeTDS' bulk insert does not support passing Unicode types. If the caller
        -:  750:        has requested a Unicode type, map it to the equivalent single-byte representation.
        -:  751:    */
    #####:  752:    enum TdsType tdstype;
    #####:  753:    BYTE* input = (BYTE*)parameter->input;
        -:  754:
        -:  755:    /*
        -:  756:        Buffer for re-encoded UTF-16LE data when downgrading an explicit
        -:  757:        SqlNVarChar/SqlNText. This must persist until after bcp_bind returns.
        -:  758:    */
    #####:  759:    PyObject* utf16_bytes = NULL;
        -:  760:
        -:  761:    /* Use the input byte count for non-NULL, variable-length types. */
    #####:  762:    DBINT cbinput = (parameter->tdstypesize > 0) ? (DBINT)parameter->ninput : parameter->tdstypesize;
branch  0 never executed
branch  1 never executed
        -:  763:
    #####:  764:    if ((parameter->tdstype == TDSNTEXT) || (parameter->tdstype == TDSNVARCHAR))
branch  0 never executed
branch  1 never executed
        -:  765:    {
        -:  766:        /*
        -:  767:            Re-encode UTF-8 to UTF-16LE only when the caller explicitly used
        -:  768:            SqlNVarChar (or SqlNText). When the NVARCHAR type was *inferred*
        -:  769:            from a bare Python str, the data should be sent as-is — the old
        -:  770:            behaviour — because the caller did not indicate an NVARCHAR target
        -:  771:            column and the warning about encoding is already emitted elsewhere.
        -:  772:        */
    #####:  773:        if (SqlType_Check(parameter->value) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  774:            (NULL != input) && (parameter->ninput > 0))
branch  0 never executed
branch  1 never executed
        -:  775:        {
    #####:  776:            PyObject* unicode_str = PyUnicode_DecodeUTF8((const char*)input,
call    0 never executed
        -:  777:                                                          (Py_ssize_t)parameter->ninput,
        -:  778:                                                          "strict");
    #####:  779:            if (!unicode_str)
branch  0 never executed
branch  1 never executed
        -:  780:            {
        -:  781:                return FAIL;
        -:  782:            }
        -:  783:
    #####:  784:            utf16_bytes = PyUnicode_AsEncodedString(unicode_str,
call    0 never executed
        -:  785:                                                     "utf-16-le",
        -:  786:                                                     "strict");
    #####:  787:            Py_DECREF(unicode_str);
branch  0 never executed
branch  1 never executed
    #####:  788:            if (!utf16_bytes)
branch  0 never executed
branch  1 never executed
        -:  789:            {
        -:  790:                return FAIL;
        -:  791:            }
        -:  792:
    #####:  793:            input = (BYTE*)PyBytes_AS_STRING(utf16_bytes);
    #####:  794:            cbinput = (DBINT)PyBytes_GET_SIZE(utf16_bytes);
        -:  795:        }
        -:  796:
        -:  797:        /*
        -:  798:            FreeTDS does not support passing *VARCHAR(MAX) types.
        -:  799:            Use the *TEXT types instead.
        -:  800:            Use cbinput (the re-encoded byte count) for the threshold check
        -:  801:            since that is what will actually be sent on the wire.
        -:  802:        */
    #####:  803:        tdstype = (cbinput > (DBINT)TDS_CHAR_MAX_SIZE) ? TDSTEXT : TDSVARCHAR;
branch  0 never executed
branch  1 never executed
        -:  804:    }
        -:  805:    else
        -:  806:    {
        -:  807:        tdstype = parameter->tdstype;
        -:  808:    }
        -:  809:
        -:  810:    /*
        -:  811:        0-length, non-NULL inputs are intended to be empty strings, but to
        -:  812:        properly pass an empty string, a NULL-terminated string must be
        -:  813:        provided to `bcp_bind`.
        -:  814:    */
    #####:  815:    if ((0 == parameter->ninput) && (NULL != input))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  816:    {
        -:  817:#if CTDS_SUPPORT_BCP_EMPTY_STRING
    #####:  818:        input = (BYTE*)"";
    #####:  819:        cbinput = -1;
        -:  820:#else /* if CTDS_SUPPORT_BCP_EMPTY_STRING */
        -:  821:        if (PyErr_WarnEx(PyExc_tds_Warning,
        -:  822:                         "\"\" converted to NULL for compatibility with FreeTDS."
        -:  823:                         " Please update to a recent version of FreeTDS.",
        -:  824:                         1))
        -:  825:        {
        -:  826:            Py_XDECREF(utf16_bytes);
        -:  827:            return FAIL;
        -:  828:        }
        -:  829:#endif /* else if CTDS_SUPPORT_BCP_EMPTY_STRING */
        -:  830:    }
        -:  831:
        -:  832:    {
    #####:  833:        RETCODE rc = bcp_bind(dbproc,
call    0 never executed
        -:  834:                              input,
        -:  835:                              0,
        -:  836:                              cbinput,
        -:  837:                              NULL,
        -:  838:                              0,
        -:  839:                              tdstype,
        -:  840:                              (int)column);
        -:  841:
        -:  842:        /*
        -:  843:            Store the re-encoded buffer as the parameter's source so it stays
        -:  844:            alive for the duration of the BCP operation (FreeTDS may reference
        -:  845:            the bound buffer until bcp_sendrow/bcp_done).
        -:  846:        */
    #####:  847:        if (utf16_bytes)
branch  0 never executed
branch  1 never executed
        -:  848:        {
    #####:  849:            Py_XDECREF(parameter->source);
call    0 never executed
    #####:  850:            parameter->source = utf16_bytes;
        -:  851:            /* Update input/ninput so any subsequent access sees the UTF-16LE data. */
    #####:  852:            parameter->input = (const void*)PyBytes_AS_STRING(utf16_bytes);
    #####:  853:            parameter->ninput = (size_t)PyBytes_GET_SIZE(utf16_bytes);
        -:  854:        }
        -:  855:
        -:  856:        return rc;
        -:  857:    }
        -:  858:}
        -:  859:
        -:  860:
function Parameter_output called 0 returned 0% blocks executed 0%
    #####:  861:bool Parameter_output(struct Parameter* rpcparam)
        -:  862:{
    #####:  863:    return (NULL != rpcparam->output);
        -:  864:}
        -:  865:
function Parameter_sqltype called 0 returned 0% blocks executed 0%
    #####:  866:char* Parameter_sqltype(struct Parameter* rpcparam, bool maximum_width)
        -:  867:{
    #####:  868:    char* sql = NULL;
    #####:  869:    switch (rpcparam->tdstype)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
branch 22 never executed
branch 23 never executed
branch 24 never executed
branch 25 never executed
        -:  870:    {
        -:  871:#define CONST_CASE(_type) \
        -:  872:        case TDS ## _type: { sql = tds_mem_strdup(STRINGIFY(_type)); break; }
        -:  873:
    #####:  874:        case TDSNVARCHAR:
        -:  875:        {
        -:  876:#if defined(__GNUC__) && (__GNUC__ > 7)
        -:  877:#  pragma GCC diagnostic push
        -:  878:#  pragma GCC diagnostic ignored "-Wimplicit-fallthrough"
        -:  879:#endif /* if defined(__GNUC__) && (__GNUC__ > 7) */
    #####:  880:            if ((rpcparam->tdstypesize > TDS_NCHAR_MAX_SIZE) || maximum_width)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  881:            {
    #####:  882:                sql = tds_mem_strdup("NVARCHAR(MAX)");
    #####:  883:                break;
call    0 never executed
        -:  884:            }
        -:  885:#if defined(__GNUC__) && (__GNUC__ > 7)
        -:  886:#  pragma GCC diagnostic pop
        -:  887:#endif
        -:  888:            /* Intentional fall-though. */
        -:  889:        }
        -:  890:        case TDSNCHAR:
        -:  891:        {
        -:  892:            /* The typesize will be 0 for NULL values, but the SQL type size must be 1. */
    #####:  893:            assert(0 <= rpcparam->tdstypesize && rpcparam->tdstypesize <= TDS_NCHAR_MAX_SIZE);
    #####:  894:            sql = tds_mem_malloc(ARRAYSIZE("NVARCHAR(2147483647)"));
    #####:  895:            if (sql)
branch  0 never executed
branch  1 never executed
        -:  896:            {
    #####:  897:                (void)sprintf(sql,
        -:  898:                              "N%sCHAR(%d)",
        -:  899:                              (TDSNCHAR == rpcparam->tdstype) ? "" : "VAR",
    #####:  900:                              MAX(rpcparam->tdstypesize, 1));
branch  0 never executed
branch  1 never executed
        -:  901:            }
        -:  902:            break;
        -:  903:        }
    #####:  904:        case TDSVARCHAR:
        -:  905:        {
        -:  906:#if defined(__GNUC__) && (__GNUC__ > 7)
        -:  907:#  pragma GCC diagnostic push
        -:  908:#  pragma GCC diagnostic ignored "-Wimplicit-fallthrough"
        -:  909:#endif /* if defined(__GNUC__) && (__GNUC__ > 7) */
    #####:  910:            if ((rpcparam->tdstypesize > TDS_CHAR_MAX_SIZE) || maximum_width)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  911:            {
    #####:  912:                sql = tds_mem_strdup("VARCHAR(MAX)");
    #####:  913:                break;
call    0 never executed
        -:  914:            }
        -:  915:#if defined(__GNUC__) && (__GNUC__ > 7)
        -:  916:#  pragma GCC diagnostic pop
        -:  917:#endif
        -:  918:            /* Intentional fall-though. */
        -:  919:        }
        -:  920:        case TDSCHAR:
        -:  921:        {
        -:  922:            /* The typesize will be 0 for NULL values, but the SQL type size must be 1. */
    #####:  923:            assert(0 <= rpcparam->tdstypesize && rpcparam->tdstypesize <= TDS_CHAR_MAX_SIZE);
    #####:  924:            sql = tds_mem_malloc(ARRAYSIZE("VARCHAR(2147483647)"));
    #####:  925:            if (sql)
branch  0 never executed
branch  1 never executed
        -:  926:            {
    #####:  927:                (void)sprintf(sql,
        -:  928:                              "%sCHAR(%d)",
        -:  929:                              (TDSCHAR == rpcparam->tdstype) ? "" : "VAR",
    #####:  930:                              MAX(rpcparam->tdstypesize, 1));
branch  0 never executed
branch  1 never executed
        -:  931:            }
        -:  932:            break;
        -:  933:        }
    #####:  934:        CONST_CASE(NTEXT)
call    0 never executed
    #####:  935:        CONST_CASE(TEXT)
call    0 never executed
        -:  936:
    #####:  937:        case TDSBITN:
    #####:  938:        CONST_CASE(BIT)
call    0 never executed
        -:  939:
    #####:  940:        case TDSINTN: /* INTN can represent up to 32 bit integers. */
        -:  941:        case TDSINT:
        -:  942:        case TDSTINYINT:
        -:  943:        case TDSSMALLINT:
        -:  944:        case TDSBIGINT:
        -:  945:        {
    #####:  946:            const char* prefix = "";
    #####:  947:            if (maximum_width || TDSBIGINT == rpcparam->tdstype)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  948:            {
        -:  949:                prefix = "BIG";
        -:  950:            }
    #####:  951:            else if (TDSTINYINT == rpcparam->tdstype)
branch  0 never executed
branch  1 never executed
        -:  952:            {
        -:  953:                prefix = "TINY";
        -:  954:            }
    #####:  955:            else if (TDSSMALLINT == rpcparam->tdstype)
branch  0 never executed
branch  1 never executed
        -:  956:            {
    #####:  957:                prefix = "SMALL";
        -:  958:            }
    #####:  959:            sql = tds_mem_malloc(ARRAYSIZE("SMALLINT"));
    #####:  960:            if (sql)
branch  0 never executed
branch  1 never executed
        -:  961:            {
    #####:  962:                (void)sprintf(sql, "%sINT", prefix);
        -:  963:            }
        -:  964:            break;
        -:  965:        }
        -:  966:
    #####:  967:        case TDSFLOAT:
        -:  968:        case TDSFLOATN:
        -:  969:        {
        -:  970:            /* $TODO: support variable sized floats */
    #####:  971:            sql = tds_mem_strdup("FLOAT");
    #####:  972:            break;
call    0 never executed
        -:  973:        }
    #####:  974:        CONST_CASE(REAL)
call    0 never executed
        -:  975:
    #####:  976:        case TDSDATETIMEN:
    #####:  977:        CONST_CASE(DATETIME)
call    0 never executed
    #####:  978:        CONST_CASE(DATETIME2)
call    0 never executed
    #####:  979:        CONST_CASE(DATETIMEOFFSET)
call    0 never executed
    #####:  980:        CONST_CASE(SMALLDATETIME)
call    0 never executed
    #####:  981:        CONST_CASE(DATE)
call    0 never executed
    #####:  982:        CONST_CASE(TIME)
call    0 never executed
        -:  983:
    #####:  984:        CONST_CASE(IMAGE)
call    0 never executed
        -:  985:
    #####:  986:        CONST_CASE(SMALLMONEY)
call    0 never executed
    #####:  987:        case TDSMONEYN:
    #####:  988:        CONST_CASE(MONEY)
call    0 never executed
        -:  989:
    #####:  990:        case TDSNUMERIC:
        -:  991:        case TDSDECIMAL:
        -:  992:        {
    #####:  993:            sql = tds_mem_malloc(ARRAYSIZE("DECIMAL(255,255)"));
    #####:  994:            if (sql)
branch  0 never executed
branch  1 never executed
        -:  995:            {
    #####:  996:                const DBDECIMAL* dbdecimal = (const DBDECIMAL*)rpcparam->input;
    #####:  997:                (void)sprintf(sql,
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  998:                              "%s(%d,%d)",
        -:  999:                              (TDSNUMERIC == rpcparam->tdstype) ? "NUMERIC" : "DECIMAL",
    #####: 1000:                              (dbdecimal) ? dbdecimal->precision : 1,
    #####: 1001:                              (dbdecimal) ? dbdecimal->scale : 0);
        -: 1002:            }
        -: 1003:            break;
        -: 1004:        }
        -: 1005:
    #####: 1006:        case TDSVARBINARY:
        -: 1007:        {
        -: 1008:#if defined(__GNUC__) && (__GNUC__ > 7)
        -: 1009:#  pragma GCC diagnostic push
        -: 1010:#  pragma GCC diagnostic ignored "-Wimplicit-fallthrough"
        -: 1011:#endif /* if defined(__GNUC__) && (__GNUC__ > 7) */
    #####: 1012:            if ((rpcparam->tdstypesize > TDS_BINARY_MAX_SIZE) || maximum_width)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1013:            {
    #####: 1014:                sql = tds_mem_strdup("VARBINARY(MAX)");
    #####: 1015:                break;
call    0 never executed
        -: 1016:            }
        -: 1017:#if defined(__GNUC__) && (__GNUC__ > 7)
        -: 1018:#  pragma GCC diagnostic pop
        -: 1019:#endif
        -: 1020:            /* Intentional fall-though. */
        -: 1021:        }
        -: 1022:        case TDSBINARY:
        -: 1023:        {
    #####: 1024:            assert(1 <= rpcparam->tdstypesize && rpcparam->tdstypesize <= TDS_BINARY_MAX_SIZE);
    #####: 1025:            sql = tds_mem_malloc(ARRAYSIZE("VARBINARY(" STRINGIFY(TDS_BINARY_MAX_SIZE) ")"));
    #####: 1026:            if (sql)
branch  0 never executed
branch  1 never executed
        -: 1027:            {
    #####: 1028:                (void)sprintf(sql,
branch  0 never executed
branch  1 never executed
        -: 1029:                              "%sBINARY(%d)",
        -: 1030:                              (TDSBINARY == rpcparam->tdstype) ? "" : "VAR",
        -: 1031:                              rpcparam->tdstypesize);
        -: 1032:            }
        -: 1033:            break;
        -: 1034:        }
        -: 1035:
    #####: 1036:        CONST_CASE(GUID)
call    0 never executed
    #####: 1037:        CONST_CASE(XML)
call    0 never executed
    #####: 1038:        CONST_CASE(VOID)
call    0 never executed
        -: 1039:        default:
        -: 1040:        {
        -: 1041:            break;
        -: 1042:        }
        -: 1043:    }
    #####: 1044:    return sql;
        -: 1045:}
        -: 1046:
function Parameter_value called 0 returned 0% blocks executed 0%
    #####: 1047:PyObject* Parameter_value(struct Parameter* rpcparam)
        -: 1048:{
    #####: 1049:    return rpcparam->value;
        -: 1050:}
        -: 1051:
        -: 1052:#if !defined(CTDS_USE_SP_EXECUTESQL)
        -: 1053:
        -: 1054:char* Parameter_serialize(struct Parameter* rpcparam, bool maximum_width, size_t* nserialized)
        -: 1055:{
        -: 1056:    char* serialized = NULL;
        -: 1057:    char* value = NULL;
        -: 1058:    bool convert = true;
        -: 1059:    if (NULL == rpcparam->input)
        -: 1060:    {
        -: 1061:        value = tds_mem_strdup("NULL");
        -: 1062:        if (value)
        -: 1063:        {
        -: 1064:            *nserialized = ARRAYSIZE("NULL") - 1;
        -: 1065:        }
        -: 1066:        else
        -: 1067:        {
        -: 1068:            PyErr_NoMemory();
        -: 1069:        }
        -: 1070:    }
        -: 1071:    else
        -: 1072:    {
        -: 1073:        switch (rpcparam->tdstype)
        -: 1074:        {
        -: 1075:            case TDSNCHAR:
        -: 1076:            case TDSCHAR:
        -: 1077:            case TDSNVARCHAR:
        -: 1078:            case TDSVARCHAR:
        -: 1079:            case TDSNTEXT:
        -: 1080:            case TDSTEXT:
        -: 1081:            {
        -: 1082:                const char* input = (const char*)rpcparam->input;
        -: 1083:                size_t written = 0;
        -: 1084:
        -: 1085:                /*
        -: 1086:                    Escape the string for SQL by replacing "'" with "''".
        -: 1087:
        -: 1088:                    The first pass computes the size of the escaped string.
        -: 1089:                    The second pass allocates a buffer and then escapes the string
        -: 1090:                    to the buffer.
        -: 1091:                */
        -: 1092:                int write;
        -: 1093:                for (write = 0; write < 2; ++write)
        -: 1094:                {
        -: 1095:                    size_t ixsrc;
        -: 1096:                    if (write)
        -: 1097:                    {
        -: 1098:                        value = tds_mem_malloc(written);
        -: 1099:                        if (!value)
        -: 1100:                        {
        -: 1101:                            PyErr_NoMemory();
        -: 1102:                            break;
        -: 1103:                        }
        -: 1104:                        written = 0;
        -: 1105:                    }
        -: 1106:
        -: 1107:                    if (write) { value[written] = '\''; }
        -: 1108:                    ++written;
        -: 1109:
        -: 1110:                    for (ixsrc = 0; ixsrc < rpcparam->ninput; ++ixsrc)
        -: 1111:                    {
        -: 1112:                        switch (input[ixsrc])
        -: 1113:                        {
        -: 1114:                            case '\'':
        -: 1115:                            {
        -: 1116:                                if (write) { value[written] = '\''; }
        -: 1117:#if defined(__GNUC__) && (__GNUC__ > 7)
        -: 1118:#  pragma GCC diagnostic push
        -: 1119:#  pragma GCC diagnostic ignored "-Wimplicit-fallthrough"
        -: 1120:#endif /* if defined(__GNUC__) && (__GNUC__ > 7) */
        -: 1121:                                ++written;
        -: 1122:#if defined(__GNUC__) && (__GNUC__ > 7)
        -: 1123:#  pragma GCC diagnostic pop
        -: 1124:#endif
        -: 1125:                                /* Intentional fall-through. */
        -: 1126:                            }
        -: 1127:                            default:
        -: 1128:                            {
        -: 1129:                                if (write) { value[written] = input[ixsrc]; }
        -: 1130:                                ++written;
        -: 1131:                                break;
        -: 1132:                            }
        -: 1133:                        }
        -: 1134:                    }
        -: 1135:
        -: 1136:                    if (write) { value[written] = '\''; }
        -: 1137:                    ++written;
        -: 1138:                    if (write) { value[written] = '\0'; }
        -: 1139:                    ++written;
        -: 1140:                }
        -: 1141:                *nserialized = written - 1;
        -: 1142:
        -: 1143:                convert = ((TDSCHAR == rpcparam->tdstype) ||
        -: 1144:                           (TDSNCHAR == rpcparam->tdstype) ||
        -: 1145:                           ((size_t)rpcparam->tdstypesize != rpcparam->ninput));
        -: 1146:                break;
        -: 1147:            }
        -: 1148:            case TDSBINARY:
        -: 1149:            case TDSVARBINARY:
        -: 1150:            case TDSIMAGE:
        -: 1151:            {
        -: 1152:                size_t ix, written = 0;
        -: 1153:
        -: 1154:                /* Large enough for the hexadecimal representation. */
        -: 1155:                value = tds_mem_malloc(ARRAYSIZE("0x") + rpcparam->ninput * 2 + 1 /* '\0' */);
        -: 1156:                if (!value)
        -: 1157:                {
        -: 1158:                    PyErr_NoMemory();
        -: 1159:                    break;
        -: 1160:                }
        -: 1161:                written += (size_t)sprintf(&value[written], "0x");
        -: 1162:                for (ix = 0; ix < rpcparam->ninput; ++ix)
        -: 1163:                {
        -: 1164:                    const unsigned char byte = ((unsigned char*)rpcparam->input)[ix];
        -: 1165:                    written += (size_t)sprintf(&value[written], "%02x", byte);
        -: 1166:                }
        -: 1167:                value[written] = '\0';
        -: 1168:                *nserialized = written - 1;
        -: 1169:                break;
        -: 1170:            }
        -: 1171:            case TDSDATE:
        -: 1172:            case TDSDATETIME:
        -: 1173:            case TDSDATETIME2:
        -: 1174:            case TDSDATETIMEOFFSET:
        -: 1175:            case TDSTIME:
        -: 1176:            case TDSMONEY:
        -: 1177:            case TDSDECIMAL:
        -: 1178:            case TDSFLOAT:
        -: 1179:            {
        -: 1180:                size_t written = 0;
        -: 1181:                DBINT result;
        -: 1182:
        -: 1183:                size_t nvalue;
        -: 1184:                bool quoted = false;
        -: 1185:
        -: 1186:                switch (rpcparam->tdstype)
        -: 1187:                {
        -: 1188:                    case TDSMONEY:
        -: 1189:                    case TDSDECIMAL:
        -: 1190:                    {
        -: 1191:                        nvalue = 1 /* '-' */ + 38 + 1 /* '.' */ + 1 /* '\0' */;
        -: 1192:                        break;
        -: 1193:                    }
        -: 1194:                    case TDSFLOAT:
        -: 1195:                    {
        -: 1196:                        nvalue = 1 /* '-' */ + 15 + 1 /* '.' */ + 5 /* e+123 */ + 1 /* '\0' */;
        -: 1197:                        break;
        -: 1198:                    }
        -: 1199:                    default:
        -: 1200:                    {
        -: 1201:                        quoted = true;
        -: 1202:                        nvalue = ARRAYSIZE("'YYYY-MM-DD hh:mm:ss.nnnnnnn +HH:MM'");
        -: 1203:                        break;
        -: 1204:                    }
        -: 1205:                }
        -: 1206:
        -: 1207:                value = tds_mem_malloc(nvalue);
        -: 1208:                if (!value)
        -: 1209:                {
        -: 1210:                    PyErr_NoMemory();
        -: 1211:                    break;
        -: 1212:                }
        -: 1213:
        -: 1214:                if (quoted)
        -: 1215:                {
        -: 1216:                    value[written++] = '\'';
        -: 1217:                }
        -: 1218:                result = dbconvert(NULL,
        -: 1219:                                   rpcparam->tdstype,
        -: 1220:                                   (BYTE*)rpcparam->input,
        -: 1221:                                   -1,
        -: 1222:                                   TDSCHAR,
        -: 1223:                                   (BYTE*)&value[written],
        -: 1224:                                   (DBINT)(nvalue - written));
        -: 1225:                assert(-1 != result);
        -: 1226:                written += (size_t)result;
        -: 1227:                if (quoted)
        -: 1228:                {
        -: 1229:                    value[written++] = '\'';
        -: 1230:                }
        -: 1231:                value[written] = '\0';
        -: 1232:                *nserialized = written - 1;
        -: 1233:                break;
        -: 1234:            }
        -: 1235:            case TDSBITN:
        -: 1236:            case TDSTINYINT:
        -: 1237:            case TDSSMALLINT:
        -: 1238:            case TDSINT:
        -: 1239:            case TDSBIGINT:
        -: 1240:            {
        -: 1241:                union
        -: 1242:                {
        -: 1243:                    uint8_t tiny;
        -: 1244:                    int16_t small;
        -: 1245:                    int32_t int_;
        -: 1246:                    int64_t big;
        -: 1247:                } ints;
        -: 1248:                memset(&ints, 0, sizeof(ints));
        -: 1249:
        -: 1250:                value = tds_mem_malloc(ARRAYSIZE("-9223372036854775808"));
        -: 1251:                if (!value)
        -: 1252:                {
        -: 1253:                    PyErr_NoMemory();
        -: 1254:                    break;
        -: 1255:                }
        -: 1256:                memcpy(&ints, rpcparam->input, rpcparam->ninput);
        -: 1257:                if (TDSBIGINT == rpcparam->tdstype)
        -: 1258:                {
        -: 1259:                    *nserialized = (size_t)sprintf(value, "%lli", (long long int)ints.big);
        -: 1260:                }
        -: 1261:                else if (TDSINT == rpcparam->tdstype)
        -: 1262:                {
        -: 1263:                    *nserialized = (size_t)sprintf(value, "%i", ints.int_);
        -: 1264:                }
        -: 1265:                else if (TDSSMALLINT == rpcparam->tdstype)
        -: 1266:                {
        -: 1267:                    *nserialized = (size_t)sprintf(value, "%i", ints.small);
        -: 1268:                }
        -: 1269:                else
        -: 1270:                {
        -: 1271:                    *nserialized = (size_t)sprintf(value, "%u", ints.tiny);
        -: 1272:                }
        -: 1273:                break;
        -: 1274:            }
        -: 1275:            default:
        -: 1276:            {
        -: 1277:                PyErr_Format(PyExc_tds_InterfaceError, "failed to serialize TDS type %d", rpcparam->tdstype);
        -: 1278:                break;
        -: 1279:            }
        -: 1280:        }
        -: 1281:    }
        -: 1282:
        -: 1283:    if (!PyErr_Occurred())
        -: 1284:    {
        -: 1285:        if (convert)
        -: 1286:        {
        -: 1287:            char* type = Parameter_sqltype(rpcparam, maximum_width);
        -: 1288:            if (type)
        -: 1289:            {
        -: 1290:                serialized = tds_mem_malloc(
        -: 1291:                    ARRAYSIZE("CONVERT(") + strlen(type) + ARRAYSIZE(",") + strlen(value) + ARRAYSIZE(")")
        -: 1292:                );
        -: 1293:                if (serialized)
        -: 1294:                {
        -: 1295:                    *nserialized = (size_t)sprintf(serialized, "CONVERT(%s,%s)", type, value);
        -: 1296:                }
        -: 1297:                else
        -: 1298:                {
        -: 1299:                    PyErr_NoMemory();
        -: 1300:                }
        -: 1301:                tds_mem_free(type);
        -: 1302:            }
        -: 1303:        }
        -: 1304:        else
        -: 1305:        {
        -: 1306:            serialized = value;
        -: 1307:            value = NULL;
        -: 1308:        }
        -: 1309:    }
        -: 1310:
        -: 1311:    if (PyErr_Occurred())
        -: 1312:    {
        -: 1313:        tds_mem_free(serialized);
        -: 1314:        serialized = NULL;
        -: 1315:        *nserialized = 0;
        -: 1316:    }
        -: 1317:
        -: 1318:    tds_mem_free(value);
        -: 1319:
        -: 1320:    return serialized;
        -: 1321:}
        -: 1322:#endif /* if !defined(CTDS_USE_SP_EXECUTESQL) */
        -: 1323:
function ParameterType_init called 0 returned 0% blocks executed 0%
    #####: 1324:PyTypeObject* ParameterType_init(void)
        -: 1325:{
    #####: 1326:    if (0 != PyType_Ready(&ParameterType))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1327:    {
    #####: 1328:        return NULL;
        -: 1329:    }
        -: 1330:    return &ParameterType;
        -: 1331:}
        -: 1332:
function ParameterType_get called 0 returned 0% blocks executed 0%
    #####: 1333:PyTypeObject* ParameterType_get(void)
        -: 1334:{
    #####: 1335:    Py_INCREF(&ParameterType);
branch  0 never executed
branch  1 never executed
    #####: 1336:    return &ParameterType;
        -: 1337:}
        -: 1338:
function Parameter_Check called 0 returned 0% blocks executed 0%
    #####: 1339:int Parameter_Check(PyObject* o)
        -: 1340:{
    #####: 1341:    return PyObject_TypeCheck(o, &ParameterType);
branch  0 never executed
branch  1 never executed
        -: 1342:}
