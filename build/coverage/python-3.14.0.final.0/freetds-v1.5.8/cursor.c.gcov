        -:    0:Source:src/k_ctds/cursor.c
        -:    0:Source is newer than graph
        -:    1:#include "include/push_warnings.h"
        -:    2:#include <Python.h>
        -:    3:#include <sybdb.h>
        -:    4:#include "include/pop_warnings.h"
        -:    5:
        -:    6:#include <assert.h>
        -:    7:#include <stddef.h>
        -:    8:
        -:    9:#include "include/c99int.h"
        -:   10:#include "include/cursor.h"
        -:   11:#include "include/connection.h"
        -:   12:#include "include/macros.h"
        -:   13:#include "include/parameter.h"
        -:   14:#include "include/pyutils.h"
        -:   15:#include "include/tds.h"
        -:   16:#include "include/type.h"
        -:   17:
        -:   18:#if defined(__GNUC__) && (__GNUC__ > 4)
        -:   19:/*
        -:   20:    Ignore "string length '%d' is greater than the length '509' ISO C90
        -:   21:    compilers are required to support [-Werror=overlength-strings]".
        -:   22:*/
        -:   23:#  pragma GCC diagnostic ignored "-Woverlength-strings"
        -:   24:
        -:   25:/* Ignore "ISO C90 does not support 'long long' [-Werror=long-long]". */
        -:   26:#  pragma GCC diagnostic ignored "-Wlong-long"
        -:   27:#endif /* if defined(__GNUC__) && (__GNUC__ > 4) */
        -:   28:
        -:   29:#ifdef __clang__
        -:   30:# if PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION == 8
        -:   31:/* Ignore "'tp_print' has been explicitly marked deprecated here" */
        -:   32:#    pragma clang diagnostic push
        -:   33:#    pragma clang diagnostic ignored "-Wdeprecated-declarations"
        -:   34:#  endif /* if PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION == 8 */
        -:   35:#endif /* ifdef __clang__ */
        -:   36:
        -:   37:
        -:   38:struct Column {
        -:   39:    DBCOL dbcol;
        -:   40:
        -:   41:    sql_topython topython;
        -:   42:};
        -:   43:
        -:   44:/* A description of the columns in a result set. */
        -:   45:struct ResultSetDescription {
        -:   46:
        -:   47:    size_t _refs;
        -:   48:
        -:   49:    /*
        -:   50:      The Python object representation of the description. This will be NULL
        -:   51:       until requested the first time, then built and cached.
        -:   52:    */
        -:   53:    PyObject* _obj;
        -:   54:
        -:   55:    /*
        -:   56:        Number of columns in the current resultset. This will be 0 if there
        -:   57:        is no current result set.
        -:   58:    */
        -:   59:    size_t ncolumns;
        -:   60:
        -:   61:#if defined(__GNUC__) && (__GNUC__ > 4)
        -:   62:#  pragma GCC diagnostic push
        -:   63:#  pragma GCC diagnostic ignored "-Wpedantic"
        -:   64:#endif /* if defined(__GNUC__) && (__GNUC__ > 4) */
        -:   65:#if defined (_MSC_VER)
        -:   66:#  pragma warning(disable: 4200)
        -:   67:#endif /* if defined (_MSC_VER) */
        -:   68:
        -:   69:    /* A dynamically-sized array of columns, of length `ncolumns`. */
        -:   70:    struct Column columns[];
        -:   71:
        -:   72:#if defined (_MSC_VER)
        -:   73:#  pragma warning(default: 4200)
        -:   74:#endif /* if defined (_MSC_VER) */
        -:   75:#if defined(__GNUC__) && (__GNUC__ > 4)
        -:   76:#  pragma GCC diagnostic pop
        -:   77:#endif /* if defined(__GNUC__) && (__GNUC__ > 4) */
        -:   78:};
        -:   79:
        -:   80:#define ResultSetDescription_size(_ncolumns) \
        -:   81:    (offsetof(struct ResultSetDescription, columns) + (sizeof(struct Column) * (_ncolumns)))
        -:   82:
function ResultSetDescription_create called 0 returned 0% blocks executed 0%
    #####:   83:struct ResultSetDescription* ResultSetDescription_create(size_t ncolumns)
        -:   84:{
    #####:   85:    struct ResultSetDescription* description = tds_mem_malloc(ResultSetDescription_size(ncolumns));
    #####:   86:    if (description)
branch  0 never executed
branch  1 never executed
        -:   87:    {
    #####:   88:        description->_refs = 1;
    #####:   89:        description->_obj = NULL;
    #####:   90:        description->ncolumns = ncolumns;
    #####:   91:        memset(description->columns, 0, sizeof(struct Column) * ncolumns);
        -:   92:    }
    #####:   93:    return description;
        -:   94:}
        -:   95:
        -:   96:#define ResultSetDescription_increment(_description) \
        -:   97:    (_description)->_refs++
        -:   98:
function ResultSetDescription_decrement called 0 returned 0% blocks executed 0%
    #####:   99:static void ResultSetDescription_decrement(struct ResultSetDescription* description)
        -:  100:{
    #####:  101:    description->_refs--;
    #####:  102:    if (0 == description->_refs)
branch  0 never executed
branch  1 never executed
        -:  103:    {
    #####:  104:        Py_XDECREF(description->_obj);
call    0 never executed
    #####:  105:        tds_mem_free(description);
        -:  106:    }
    #####:  107:}
        -:  108:
        -:  109:
        -:  110:struct Cursor {
        -:  111:    PyObject_VAR_HEAD
        -:  112:
        -:  113:    /*
        -:  114:        The underlying database connection used by this cursor.
        -:  115:        The cursor holds a reference to the connection while open.
        -:  116:        Closing the cursor (via close() or __del__()) releases the
        -:  117:        reference and effectively makes the cursor useless.
        -:  118:    */
        -:  119:    struct Connection* connection;
        -:  120:
        -:  121:    /*
        -:  122:        The batch size for the fetchmany operation.
        -:  123:        See https://www.python.org/dev/peps/pep-0249/#arraysize.
        -:  124:    */
        -:  125:    unsigned PY_LONG_LONG arraysize;
        -:  126:
        -:  127:    /* A description of the current result set columns. */
        -:  128:    struct ResultSetDescription* description;
        -:  129:
        -:  130:    /* The number of rows read from the current result set. */
        -:  131:    size_t rowsread;
        -:  132:
        -:  133:    /*
        -:  134:        The paramstyle to use on .execute*() calls.
        -:  135:    */
        -:  136:    enum ParamStyle paramstyle;
        -:  137:};
        -:  138:
        -:  139:#define warn_extension_used(_method) \
        -:  140:    PyErr_WarnEx(PyExc_Warning, "DB-API extension " _method " used", 1)
        -:  141:
        -:  142:#define Cursor_verify_open(_cursor) \
        -:  143:    if (!(_cursor)->connection) \
        -:  144:    { \
        -:  145:        PyErr_Format(PyExc_tds_InterfaceError, "cursor closed"); \
        -:  146:        return NULL; \
        -:  147:    }
        -:  148:
        -:  149:#define Cursor_verify_connection_open(_cursor) \
        -:  150:    if (!Connection_DBPROCESS((_cursor)->connection)) \
        -:  151:    { \
        -:  152:        Connection_raise_closed((_cursor)->connection); \
        -:  153:        return NULL; \
        -:  154:    }
        -:  155:
        -:  156:/*
        -:  157:    Clear a cursor's notion of the current resultset.
        -:  158:
        -:  159:    @note This method does not consume remaining unread rows in the
        -:  160:        resultset. That occurs in Cursor_next_resultset(), which
        -:  161:        runs outside the GIL.
        -:  162:*/
    #####:  163:static void Cursor_clear_resultset(struct Cursor* cursor)
        -:  164:{
    #####:  165:    if (cursor->description)
        -:  166:    {
    #####:  167:        ResultSetDescription_decrement(cursor->description);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  168:        cursor->description = NULL;
        -:  169:    }
    #####:  170:    cursor->rowsread = 0;
        -:  171:}
        -:  172:
        -:  173:/*
        -:  174:    Close a cursor's connection.
        -:  175:
        -:  176:    This method can be called multiple times on the same cursor.
        -:  177:*/
function Cursor_close_connection called 0 returned 0% blocks executed 0%
    #####:  178:static void Cursor_close_connection(struct Cursor* cursor)
        -:  179:{
    #####:  180:    Cursor_clear_resultset(cursor);
branch  0 never executed
branch  1 never executed
    #####:  181:    Py_XDECREF(cursor->connection);
call    0 never executed
    #####:  182:    cursor->connection = NULL;
    #####:  183:}
        -:  184:
        -:  185:/*
        -:  186:    Load the next resultset column data.
        -:  187:
        -:  188:    @note This method does not manipulate the GIL. Callers should release
        -:  189:        the GIL when calling this method.
        -:  190:
        -:  191:    @param cursor [in] The cursor object.
        -:  192:    @param retcode [out] The dblib result. If this is not FAIL on a failure,
        -:  193:        consult errno for the system failure.
        -:  194:
        -:  195:    @return 0 if the call succeeded, -1 if it failed.
        -:  196:*/
function Cursor_next_resultset called 0 returned 0% blocks executed 0%
    #####:  197:static int Cursor_next_resultset(struct Cursor* cursor, RETCODE* retcode)
        -:  198:{
    #####:  199:    DBINT ncolumns;
    #####:  200:    DBINT column;
    #####:  201:    DBPROCESS* dbproc = Connection_DBPROCESS(cursor->connection);
        -:  202:
        -:  203:#if PY_VERSION_HEX >= 0x03040000
        -:  204:    /* GIL should not be held when this function is called. */
    #####:  205:    assert(!PyGILState_Check());
        -:  206:#endif /* if PY_VERSION_HEX >= 0x03040000 */
        -:  207:
        -:  208:    /* Cursor_clear_resultset() must have already been called. */
    #####:  209:    assert(!cursor->description);
    #####:  210:    assert(0 == cursor->rowsread);
        -:  211:
        -:  212:    /* Read any unprocessed rows from the database. */
    #####:  213:    while (dbnextrow(dbproc) != NO_MORE_ROWS) {}
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  214:
        -:  215:    /*
        -:  216:        dbresults() sometimes returns SUCCEED and dbnumcols() returns 0.
        -:  217:        In this case, keep looking for the next resultset.
        -:  218:    */
    #####:  219:    for (ncolumns = 0; 0 == ncolumns; ncolumns = dbnumcols(dbproc))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  220:    {
    #####:  221:        *retcode = dbresults(dbproc);
call    0 never executed
    #####:  222:        if (SUCCEED != *retcode /* retcode may be NO_MORE_RESULTS */)
branch  0 never executed
branch  1 never executed
        -:  223:        {
    #####:  224:            return (NO_MORE_RESULTS == *retcode) ? 0 : -1;
branch  0 never executed
branch  1 never executed
        -:  225:        }
        -:  226:    }
        -:  227:
    #####:  228:    cursor->description = ResultSetDescription_create((size_t)ncolumns);
call    0 never executed
    #####:  229:    if (!cursor->description)
branch  0 never executed
branch  1 never executed
        -:  230:    {
        -:  231:        return -1;
        -:  232:    }
        -:  233:
    #####:  234:    for (column = 1; column <= ncolumns; ++column)
branch  0 never executed
branch  1 never executed
        -:  235:    {
    #####:  236:        *retcode = dbcolinfo(dbproc, CI_REGULAR, column, 0 /* ignored by dblib */,
    #####:  237:                             &cursor->description->columns[column - 1].dbcol);
call    0 never executed
    #####:  238:        if (FAIL == *retcode)
branch  0 never executed
branch  1 never executed
        -:  239:        {
        -:  240:            break;
        -:  241:        }
        -:  242:
    #####:  243:        cursor->description->columns[column - 1].topython =
    #####:  244:            sql_topython_lookup((enum TdsType)cursor->description->columns[column - 1].dbcol.Type);
call    0 never executed
        -:  245:    }
        -:  246:
    #####:  247:    if (FAIL == *retcode)
branch  0 never executed
branch  1 never executed
        -:  248:    {
    #####:  249:        ResultSetDescription_decrement(cursor->description);
call    0 never executed
    #####:  250:        cursor->description = NULL;
    #####:  251:        return -1;
        -:  252:    }
        -:  253:
        -:  254:    return 0;
        -:  255:}
        -:  256:
        -:  257:
        -:  258:/*
        -:  259:   Python tds.Cursor type definition.
        -:  260:*/
        -:  261:PyTypeObject CursorType;
        -:  262:
        -:  263:static const char s_tds_Cursor_doc[] =
        -:  264:    "A database cursor used to manage the context of a fetch operation.\n"
        -:  265:    "\n"
        -:  266:    ":pep:`0249#cursor-objects`\n";
        -:  267:
function Cursor_dealloc called 0 returned 0% blocks executed 0%
    #####:  268:static void Cursor_dealloc(PyObject* self)
        -:  269:{
    #####:  270:    Cursor_close_connection((struct Cursor*)self);
call    0 never executed
    #####:  271:    PyObject_Del(self);
call    0 never executed
    #####:  272:}
        -:  273:
        -:  274:/*
        -:  275:    tds.Cursor attributes
        -:  276:*/
        -:  277:
        -:  278:static const char s_Cursor_arraysize_doc[] =
        -:  279:    "The number of rows to fetch at a time with :py:meth:`.fetchmany`.\n"
        -:  280:    "\n"
        -:  281:    ":pep:`0249#arraysize`\n"
        -:  282:    "\n"
        -:  283:    ":rtype: int\n";
        -:  284:
function Cursor_arraysize_get called 0 returned 0% blocks executed 0%
    #####:  285:static PyObject* Cursor_arraysize_get(PyObject* self, void* closure)
        -:  286:{
    #####:  287:    struct Cursor* cursor = (struct Cursor*)self;
        -:  288:
    #####:  289:    return PyLong_FromUnsignedLongLong(cursor->arraysize);
call    0 never executed
        -:  290:
    #####:  291:    UNUSED(closure);
        -:  292:}
        -:  293:
function Cursor_arraysize_set called 0 returned 0% blocks executed 0%
    #####:  294:static int Cursor_arraysize_set(PyObject* self, PyObject* value, void* closure)
        -:  295:{
    #####:  296:    unsigned PY_LONG_LONG arraysize;
    #####:  297:    struct Cursor* cursor = (struct Cursor*)self;
    #####:  298:    if (
branch  0 never executed
branch  1 never executed
        -:  299:        (
        -:  300:#if PY_MAJOR_VERSION < 3
        -:  301:        !PyInt_Check(value) &&
        -:  302:#endif /* if PY_MAJOR_VERSION < 3 */
    #####:  303:        !PyLong_Check(value)
branch  0 never executed
branch  1 never executed
    #####:  304:        ) || PyBool_Check(value))
branch  0 never executed
branch  1 never executed
        -:  305:    {
    #####:  306:        PyErr_SetString(PyExc_TypeError, "arraysize");
    #####:  307:        return -1;
call    0 never executed
        -:  308:    }
        -:  309:#if PY_MAJOR_VERSION < 3
        -:  310:    if (PyInt_Check(value))
        -:  311:    {
        -:  312:        /* Note: This does not check for overflow. */
        -:  313:        arraysize = PyInt_AsUnsignedLongLongMask(value);
        -:  314:    }
        -:  315:#endif /* if PY_MAJOR_VERSION < 3 */
        -:  316:    else
        -:  317:    {
    #####:  318:        arraysize = PyLong_AsUnsignedLongLong(value);
call    0 never executed
        -:  319:    }
    #####:  320:    if (PyErr_Occurred())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  321:    {
        -:  322:        return -1;
        -:  323:    }
    #####:  324:    cursor->arraysize = arraysize;
    #####:  325:    return 0;
        -:  326:
    #####:  327:    UNUSED(closure);
        -:  328:}
        -:  329:
        -:  330:static const char s_Cursor_description_doc[] =
        -:  331:    "A description of the current result set columns.\n"
        -:  332:    "The description is a sequence of tuples, one tuple per column in the\n"
        -:  333:    "result set. The tuple describes the column data as follows:\n"
        -:  334:    "\n"
        -:  335:    "+---------------+--------------------------------------+\n"
        -:  336:    "| name          | The name of the column, if provided. |\n"
        -:  337:    "+---------------+--------------------------------------+\n"
        -:  338:    "| type_code     | The specific type of the column.     |\n"
        -:  339:    "+---------------+--------------------------------------+\n"
        -:  340:    "| display_size  | The SQL type size of the column.     |\n"
        -:  341:    "+---------------+--------------------------------------+\n"
        -:  342:    "| internal_size | The client size of the column.       |\n"
        -:  343:    "+---------------+--------------------------------------+\n"
        -:  344:    "| precision     | The precision of NUMERIC and DECIMAL |\n"
        -:  345:    "|               | columns.                             |\n"
        -:  346:    "+---------------+--------------------------------------+\n"
        -:  347:    "| scale         | The scale of NUMERIC and DECIMAL     |\n"
        -:  348:    "|               | columns.                             |\n"
        -:  349:    "+---------------+--------------------------------------+\n"
        -:  350:    "| null_ok       | Whether the column allows NULL.      |\n"
        -:  351:    "+---------------+--------------------------------------+\n"
        -:  352:    "\n"
        -:  353:    ".. note::\n"
        -:  354:    "    In Python 3+, this is a :py:class:`tuple` of\n"
        -:  355:    "    :py:func:`collections.namedtuple` objects whose members are defined\n"
        -:  356:    "    above.\n"
        -:  357:    "\n"
        -:  358:    ":pep:`0249#description`\n"
        -:  359:    "\n"
        -:  360:    ":return:\n"
        -:  361:    "    A sequence of tuples or :py:data:`None` if no results are\n"
        -:  362:    "    available.\n"
        -:  363:    ":rtype: tuple(tuple(str, int, int, int, int, int, bool))\n";
        -:  364:
        -:  365:#if PY_MAJOR_VERSION >= 3
        -:  366:
        -:  367:static PyTypeObject DescriptionType;
        -:  368:
    #####:  369:static int Description_init(void)
        -:  370:{
    #####:  371:    static PyStructSequence_Field s_fields[] =
        -:  372:    {
        -:  373:        /* name, doc */
        -:  374:        { "name", NULL },
        -:  375:        { "type_code", NULL },
        -:  376:        { "display_size", NULL },
        -:  377:        { "internal_size", NULL },
        -:  378:        { "precision", NULL },
        -:  379:        { "scale", NULL },
        -:  380:        { "null_ok", NULL },
        -:  381:        { NULL, NULL }
        -:  382:    };
    #####:  383:    static PyStructSequence_Desc s_desc = {
        -:  384:        "description",                   /* name */
        -:  385:        (char*)s_Cursor_description_doc, /* doc */
        -:  386:        s_fields,                        /* fields */
        -:  387:        ARRAYSIZE(s_fields)  - 1         /* n_in_sequence */
        -:  388:    };
        -:  389:
        -:  390:#  if PY_VERSION_HEX >= 0x03040000
    #####:  391:    return PyStructSequence_InitType2(&DescriptionType, &s_desc);
        -:  392:#  else
        -:  393:    PyStructSequence_InitType(&DescriptionType, &s_desc);
        -:  394:    return 0;
        -:  395:#  endif /* if PY_VERSION_HEX >= 0x03040000 */
        -:  396:
        -:  397:#  define Description_New() PyStructSequence_New(&DescriptionType)
        -:  398:#  define Description_GET_ITEM PyStructSequence_GET_ITEM
        -:  399:#  define Description_SET_ITEM PyStructSequence_SET_ITEM
        -:  400:
        -:  401:}
        -:  402:#else /* if PY_MAJOR_VERSION < 3 */
        -:  403:
        -:  404:#  define Description_init() 0
        -:  405:#  define Description_New() PyTuple_New(7)
        -:  406:#  define Description_GET_ITEM PyTuple_GET_ITEM
        -:  407:#  define Description_SET_ITEM PyTuple_SET_ITEM
        -:  408:
        -:  409:#endif /* else if PY_MAJOR_VERSION >= 3 */
        -:  410:
        -:  411:/*
        -:  412:  Construct the 7-item sequence, as descibed by:
        -:  413:  https://www.python.org/dev/peps/pep-0249/#description.
        -:  414:
        -:  415:    * name
        -:  416:    * type_code
        -:  417:    * display_size
        -:  418:    * internal_size
        -:  419:    * precision
        -:  420:    * scale
        -:  421:    * null_ok
        -:  422:*/
function create_column_description called 0 returned 0% blocks executed 0%
    #####:  423:static PyObject* create_column_description(const struct Column* column)
        -:  424:{
    #####:  425:    PyObject* tuple = Description_New();
call    0 never executed
    #####:  426:    if (tuple)
branch  0 never executed
branch  1 never executed
        -:  427:    {
    #####:  428:        do
    #####:  429:        {
    #####:  430:            PyObject* item;
    #####:  431:            Py_ssize_t ix = 0;
        -:  432:
        -:  433:            /* name */
    #####:  434:            item = PyUnicode_DecodeUTF8(column->dbcol.ActualName,
    #####:  435:                                        (Py_ssize_t)strlen(column->dbcol.ActualName),
call    0 never executed
        -:  436:                                        "strict");
    #####:  437:            if (!item)
branch  0 never executed
branch  1 never executed
        -:  438:            {
        -:  439:                break;
        -:  440:            }
    #####:  441:            Description_SET_ITEM(tuple, ix++, item); /* item reference stolen by Description_SET_ITEM */
call    0 never executed
        -:  442:
        -:  443:            /* type_code */
    #####:  444:            item = PyLong_FromLong(column->dbcol.Type);
call    0 never executed
    #####:  445:            if (!item)
branch  0 never executed
branch  1 never executed
        -:  446:            {
        -:  447:                break;
        -:  448:            }
    #####:  449:            Description_SET_ITEM(tuple, ix++, item); /* item reference stolen by Description_SET_ITEM */
call    0 never executed
        -:  450:
        -:  451:            /* display_size */
    #####:  452:            item = PyLong_FromLongLong((PY_LONG_LONG)column->dbcol.MaxLength);
call    0 never executed
    #####:  453:            if (!item)
branch  0 never executed
branch  1 never executed
        -:  454:            {
        -:  455:                break;
        -:  456:            }
    #####:  457:            Description_SET_ITEM(tuple, ix++, item); /* item reference stolen by Description_SET_ITEM */
call    0 never executed
        -:  458:
        -:  459:            /* internal_size */
        -:  460:            /* For now, just use the display_size value for this. */
    #####:  461:            item = PyLong_FromLongLong((PY_LONG_LONG)column->dbcol.MaxLength);
call    0 never executed
    #####:  462:            if (!item)
branch  0 never executed
branch  1 never executed
        -:  463:            {
        -:  464:                break;
        -:  465:            }
    #####:  466:            Description_SET_ITEM(tuple, ix++, item); /* item reference stolen by Description_SET_ITEM */
call    0 never executed
        -:  467:
        -:  468:            /* precision */
    #####:  469:            item = PyLong_FromUnsignedLong((unsigned long)column->dbcol.Precision);
call    0 never executed
    #####:  470:            if (!item)
branch  0 never executed
branch  1 never executed
        -:  471:            {
        -:  472:                break;
        -:  473:            }
    #####:  474:            Description_SET_ITEM(tuple, ix++, item); /* item reference stolen by PyTuple_SET_ITEM */
call    0 never executed
        -:  475:
        -:  476:            /* scale */
    #####:  477:            item = PyLong_FromUnsignedLong((unsigned long)column->dbcol.Scale);
call    0 never executed
    #####:  478:            if (!item)
branch  0 never executed
branch  1 never executed
        -:  479:            {
        -:  480:                break;
        -:  481:            }
    #####:  482:            Description_SET_ITEM(tuple, ix++, item); /* item reference stolen by Description_SET_ITEM */
call    0 never executed
        -:  483:
        -:  484:            /* null_ok */
    #####:  485:            item = PyBool_FromLong((long)column->dbcol.Null);
call    0 never executed
    #####:  486:            if (!item)
branch  0 never executed
branch  1 never executed
        -:  487:            {
        -:  488:                break;
        -:  489:            }
    #####:  490:            Description_SET_ITEM(tuple, ix++, item); /* item reference stolen by Description_SET_ITEM */
        -:  491:
    #####:  492:            return tuple;
        -:  493:        } while (0);
        -:  494:
    #####:  495:        Py_DECREF(tuple);
branch  0 never executed
branch  1 never executed
        -:  496:    }
        -:  497:    else
        -:  498:    {
    #####:  499:        PyErr_NoMemory();
call    0 never executed
        -:  500:    }
        -:  501:    return NULL;
        -:  502:}
        -:  503:
function ResultSetDescription_get_object called 0 returned 0% blocks executed 0%
    #####:  504:static PyObject* ResultSetDescription_get_object(struct ResultSetDescription* description)
        -:  505:{
    #####:  506:    if (!description->_obj)
branch  0 never executed
branch  1 never executed
        -:  507:    {
    #####:  508:        PyObject* tuple = PyTuple_New((Py_ssize_t)description->ncolumns);
call    0 never executed
    #####:  509:        if (tuple)
branch  0 never executed
branch  1 never executed
        -:  510:        {
        -:  511:            size_t ix;
    #####:  512:            for (ix = 0; ix < description->ncolumns; ++ix)
branch  0 never executed
branch  1 never executed
        -:  513:            {
    #####:  514:                PyObject* column = create_column_description(&description->columns[ix]);
call    0 never executed
    #####:  515:                if (column)
branch  0 never executed
branch  1 never executed
        -:  516:                {
    #####:  517:                    PyTuple_SET_ITEM(tuple, (Py_ssize_t)ix, column); /* column reference stolen by PyTuple_SET_ITEM */
        -:  518:                }
        -:  519:                else
        -:  520:                {
        -:  521:                    break;
        -:  522:                }
        -:  523:            }
        -:  524:
    #####:  525:            if (PyErr_Occurred())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  526:            {
    #####:  527:                Py_DECREF(tuple);
branch  0 never executed
branch  1 never executed
    #####:  528:                tuple = NULL;
        -:  529:            }
        -:  530:            else
        -:  531:            {
    #####:  532:                description->_obj = tuple;
    #####:  533:                tuple = NULL; /* reference stolen above */
        -:  534:            }
        -:  535:        }
        -:  536:        else
        -:  537:        {
    #####:  538:            PyErr_NoMemory();
call    0 never executed
        -:  539:        }
        -:  540:    }
        -:  541:
    #####:  542:    Py_XINCREF(description->_obj);
branch  0 never executed
branch  1 never executed
    #####:  543:    return description->_obj;
        -:  544:}
        -:  545:
function Cursor_description_get called 0 returned 0% blocks executed 0%
    #####:  546:static PyObject* Cursor_description_get(PyObject* self, void* closure)
        -:  547:{
    #####:  548:    struct Cursor* cursor = (struct Cursor*)self;
        -:  549:
        -:  550:    /*
        -:  551:        Return None if the resultset is empty (i.e. has no columns).
        -:  552:        This will also cover cases where no operation has occurred yet.
        -:  553:    */
    #####:  554:    if (!cursor->description)
branch  0 never executed
branch  1 never executed
        -:  555:    {
        -:  556:        Py_RETURN_NONE;
        -:  557:    }
        -:  558:
    #####:  559:    return ResultSetDescription_get_object(cursor->description);
call    0 never executed
        -:  560:
    #####:  561:    UNUSED(closure);
        -:  562:}
        -:  563:
        -:  564:static const char s_Cursor_rowcount_doc[] =
        -:  565:    "The number of rows that the last :py:meth:`.execute` produced or affected.\n"
        -:  566:    "\n"
        -:  567:    ".. note::\n"
        -:  568:    "\n"
        -:  569:    "    This value is unreliable when :py:meth:`.execute` is called with parameters\n"
        -:  570:    "    and using a version of FreeTDS prior to 1.1.\n"
        -:  571:    "\n"
        -:  572:    ":pep:`0249#rowcount`\n"
        -:  573:    "\n"
        -:  574:    ":rtype: int\n";
        -:  575:
function Cursor_rowcount_get called 0 returned 0% blocks executed 0%
    #####:  576:static PyObject* Cursor_rowcount_get(PyObject* self, void* closure)
        -:  577:{
    #####:  578:    struct Cursor* cursor = (struct Cursor*)self;
    #####:  579:    Cursor_verify_open(cursor);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  580:
        -:  581:    /*
        -:  582:        Note: the affected row count is always -1 after an RPC call.
        -:  583:        When .execute*() utilizes `sp_executesql`, this value will be -1.
        -:  584:    */
    #####:  585:    return PyLong_FromLong(dbcount(Connection_DBPROCESS(cursor->connection)));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  586:
    #####:  587:    UNUSED(closure);
        -:  588:}
        -:  589:
        -:  590:static const char s_Cursor_connection_doc[] =
        -:  591:    "A reference to the Connection object on which the cursor was created.\n"
        -:  592:    "\n"
        -:  593:    ":pep:`0249#id28`\n"
        -:  594:    "\n"
        -:  595:    ":rtype: k_ctds.Connection\n";
        -:  596:
function Cursor_connection_get called 0 returned 0% blocks executed 0%
    #####:  597:static PyObject* Cursor_connection_get(PyObject* self, void* closure)
        -:  598:{
    #####:  599:    struct Cursor* cursor = (struct Cursor*)self;
        -:  600:
    #####:  601:    if (0 != warn_extension_used("cursor.connection"))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  602:    {
        -:  603:        return NULL;
        -:  604:    }
        -:  605:
    #####:  606:    Cursor_verify_open(cursor);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  607:
    #####:  608:    Py_INCREF(cursor->connection);
branch  0 never executed
branch  1 never executed
        -:  609:    return (PyObject*)cursor->connection;
        -:  610:
    #####:  611:    UNUSED(closure);
        -:  612:}
        -:  613:
        -:  614:static const char s_Cursor_rownumber_doc[] =
        -:  615:    "The current 0-based index of the cursor in the result set or\n"
        -:  616:    ":py:data:`None` if the index cannot be determined.\n"
        -:  617:    "\n"
        -:  618:    ":pep:`0249#rownumber`\n"
        -:  619:    "\n"
        -:  620:    ":rtype: int\n";
        -:  621:
function Cursor_rownumber_get called 0 returned 0% blocks executed 0%
    #####:  622:static PyObject* Cursor_rownumber_get(PyObject* self, void* closure)
        -:  623:{
    #####:  624:    struct Cursor* cursor = (struct Cursor*)self;
        -:  625:
    #####:  626:    if (0 != warn_extension_used("cursor.rownumber"))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  627:    {
        -:  628:        return NULL;
        -:  629:    }
        -:  630:
    #####:  631:    if (cursor->description)
branch  0 never executed
branch  1 never executed
        -:  632:    {
    #####:  633:        return PyLong_FromSize_t(cursor->rowsread);
call    0 never executed
        -:  634:    }
        -:  635:    else
        -:  636:    {
        -:  637:        Py_RETURN_NONE;
        -:  638:    }
        -:  639:
    #####:  640:    UNUSED(closure);
        -:  641:}
        -:  642:
        -:  643:static const char s_Cursor_spid_doc[] =
        -:  644:    "Retrieve the SQL Server Session Process ID (SPID) for the connection or\n"
        -:  645:    ":py:data:`None` if the connection is closed.\n"
        -:  646:    "\n"
        -:  647:    ":rtype: int\n";
        -:  648:
function Cursor_spid_get called 0 returned 0% blocks executed 0%
    #####:  649:static PyObject* Cursor_spid_get(PyObject* self, void* closure)
        -:  650:{
    #####:  651:    struct Cursor* cursor = (struct Cursor*)self;
        -:  652:
    #####:  653:    DBPROCESS* dbproc;
    #####:  654:    Cursor_verify_open(cursor);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  655:
    #####:  656:    dbproc = Connection_DBPROCESS(cursor->connection);
call    0 never executed
    #####:  657:    if (dbproc)
branch  0 never executed
branch  1 never executed
        -:  658:    {
    #####:  659:        int spid = dbspid(dbproc);
call    0 never executed
    #####:  660:        return PyLong_FromLong((long)spid);
call    0 never executed
        -:  661:    }
        -:  662:    Py_RETURN_NONE;
        -:  663:
    #####:  664:    UNUSED(closure);
        -:  665:}
        -:  666:
        -:  667:static const char s_Cursor_Parameter_doc[] =
        -:  668:    "Convenience method to :py:class:`k_ctds.Parameter`.\n"
        -:  669:    "\n"
        -:  670:    ":return: A new Parameter object.\n"
        -:  671:    ":rtype: k_ctds.Parameter\n";
        -:  672:
function Cursor_Parameter_get called 0 returned 0% blocks executed 0%
    #####:  673:static PyObject* Cursor_Parameter_get(PyObject* self, void* closure)
        -:  674:{
    #####:  675:    return (PyObject*)ParameterType_get();
call    0 never executed
        -:  676:
    #####:  677:    UNUSED(self);
    #####:  678:    UNUSED(closure);
        -:  679:}
        -:  680:
        -:  681:
        -:  682:static PyGetSetDef Cursor_getset[] = {
        -:  683:    /* name, get, set, doc, closure */
        -:  684:    { (char*)"arraysize",   Cursor_arraysize_get,   Cursor_arraysize_set, (char*)s_Cursor_arraysize_doc,   NULL },
        -:  685:    { (char*)"description", Cursor_description_get, NULL,                 (char*)s_Cursor_description_doc, NULL },
        -:  686:    { (char*)"rowcount",    Cursor_rowcount_get,    NULL,                 (char*)s_Cursor_rowcount_doc,    NULL },
        -:  687:
        -:  688:    { (char*)"connection",  Cursor_connection_get,  NULL,                 (char*)s_Cursor_connection_doc,  NULL },
        -:  689:    { (char*)"rownumber",   Cursor_rownumber_get,   NULL,                 (char*)s_Cursor_rownumber_doc,   NULL },
        -:  690:    { (char*)"spid",        Cursor_spid_get,        NULL,                 (char*)s_Cursor_spid_doc,        NULL },
        -:  691:    { (char*)"Parameter",   Cursor_Parameter_get,   NULL,                 (char*)s_Cursor_Parameter_doc,   NULL },
        -:  692:    { NULL,                 NULL,                   NULL,                 NULL,                            NULL }
        -:  693:};
        -:  694:
        -:  695:/*
        -:  696:    tds.Cursor methods
        -:  697:*/
        -:  698:
function Cursor_extract_parameter_name called 0 returned 0% blocks executed 0%
    #####:  699:static const char* Cursor_extract_parameter_name(PyObject* value, PyObject** utf8)
        -:  700:{
    #####:  701:    const char* name;
    #####:  702:    assert(NULL == *utf8);
    #####:  703:    if (
branch  0 never executed
branch  1 never executed
        -:  704:#if PY_MAJOR_VERSION < 3
        -:  705:        !PyString_Check(value) &&
        -:  706:#endif /* if PY_MAJOR_VERSION < 3 */
    #####:  707:        !PyUnicode_Check(value))
branch  0 never executed
branch  1 never executed
        -:  708:    {
        -:  709:        return NULL;
        -:  710:    }
        -:  711:#if PY_MAJOR_VERSION < 3
        -:  712:    if (PyUnicode_Check(value))
        -:  713:    {
        -:  714:        *utf8 = PyUnicode_AsUTF8String(value);
        -:  715:        if (!*utf8)
        -:  716:        {
        -:  717:            return NULL;
        -:  718:        }
        -:  719:        name = PyString_AS_STRING(*utf8);
        -:  720:    }
        -:  721:    else
        -:  722:#endif /* if PY_MAJOR_VERSION < 3 */
        -:  723:    {
    #####:  724:        Py_INCREF(value);
branch  0 never executed
branch  1 never executed
    #####:  725:        *utf8 = value;
        -:  726:
        -:  727:#if PY_MAJOR_VERSION < 3
        -:  728:        assert(PyString_Check(value));
        -:  729:        name = PyString_AS_STRING(*utf8);
        -:  730:#else /* if PY_MAJOR_VERSION < 3 */
    #####:  731:        name = PyUnicode_AsUTF8(*utf8);
call    0 never executed
        -:  732:#endif /* else if PY_MAJOR_VERSION < 3 */
        -:  733:    }
        -:  734:
        -:  735:    /* Only allow string keys starting with '@' */
    #####:  736:    if ('@' != name[0])
branch  0 never executed
branch  1 never executed
        -:  737:    {
    #####:  738:        return NULL;
        -:  739:    }
        -:  740:
        -:  741:    return name;
        -:  742:}
        -:  743:/*
        -:  744:    Bind Python objects to RPC parameters for use in an RPC call.
        -:  745:
        -:  746:    This method sets an appropriate Python exception on failure.
        -:  747:
        -:  748:    @note This method requires the current thread own the GIL.
        -:  749:    @note A new reference is returned.
        -:  750:    @note dbrpcinit *must* be called before this.
        -:  751:
        -:  752:    @param cursor [in] A Cusor object.
        -:  753:    @param parameters [in] A Python dict or tuple object of parameters to bind.
        -:  754:        The parameters can be of any Python type.
        -:  755:    @param kvpairs [in] Are the parameters passed as (key, value) pairs?
        -:  756:        This is necessary to support ordered named parameters.
        -:  757:
        -:  758:    @return A Python dict or tuple object containg the bound parameters.
        -:  759:*/
function Cursor_bind called 0 returned 0% blocks executed 0%
    #####:  760:static PyObject* Cursor_bind(struct Cursor* cursor, PyObject* parameters, bool kvpairs)
        -:  761:{
    #####:  762:    RETCODE retcode = SUCCEED;
        -:  763:
    #####:  764:    Py_ssize_t nparameters = (PyDict_Check(parameters)) ? PyDict_Size(parameters) : PyTuple_GET_SIZE(parameters);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  765:    DBPROCESS* dbproc = Connection_DBPROCESS(cursor->connection);
call    0 never executed
        -:  766:
    #####:  767:    PyObject* rpcparams = (PyDict_Check(parameters)) ? PyDict_New() : PyTuple_New(nparameters);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  768:    if (!rpcparams)
branch  0 never executed
branch  1 never executed
        -:  769:    {
    #####:  770:        PyErr_NoMemory();
    #####:  771:        return NULL;
call    0 never executed
        -:  772:    }
        -:  773:
    #####:  774:    if (PyTuple_Check(parameters))
branch  0 never executed
branch  1 never executed
        -:  775:    {
        -:  776:        Py_ssize_t ix;
    #####:  777:        for (ix = 0; ix < nparameters; ++ix)
branch  0 never executed
branch  1 never executed
        -:  778:        {
    #####:  779:            struct Parameter* rpcparam;
    #####:  780:            PyObject* utf8key = NULL;
        -:  781:
    #####:  782:            do
    #####:  783:            {
    #####:  784:                const char* keystr = NULL;
    #####:  785:                PyObject* value;
    #####:  786:                if (kvpairs)
branch  0 never executed
branch  1 never executed
        -:  787:                {
    #####:  788:                    PyObject* pair = PyTuple_GET_ITEM(parameters, ix);
    #####:  789:                    assert(PyTuple_Check(pair) && PyTuple_GET_SIZE(pair) == 2);
        -:  790:
    #####:  791:                    keystr = Cursor_extract_parameter_name(PyTuple_GET_ITEM(pair, 0),
call    0 never executed
        -:  792:                                                           &utf8key);
        -:  793:
    #####:  794:                    assert(keystr);
    #####:  795:                    value = PyTuple_GET_ITEM(pair, 1);
        -:  796:                }
        -:  797:                else
        -:  798:                {
    #####:  799:                    value = PyTuple_GET_ITEM(parameters, ix);
        -:  800:                }
        -:  801:
    #####:  802:                if (!Parameter_Check(value))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  803:                {
    #####:  804:                    rpcparam = Parameter_create(value, 0 /* output */);
call    0 never executed
    #####:  805:                    if (!rpcparam)
branch  0 never executed
branch  1 never executed
        -:  806:                    {
        -:  807:                        break;
        -:  808:                    }
        -:  809:                }
        -:  810:                else
        -:  811:                {
    #####:  812:                    Py_INCREF(value);
branch  0 never executed
branch  1 never executed
        -:  813:                    rpcparam = (struct Parameter*)value;
        -:  814:                }
        -:  815:
    #####:  816:                if (0 != Parameter_bind(rpcparam, dbproc))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  817:                {
    #####:  818:                    Py_DECREF(rpcparam);
branch  0 never executed
branch  1 never executed
        -:  819:                    break;
        -:  820:                }
        -:  821:
    #####:  822:                PyTuple_SET_ITEM(rpcparams, ix, (PyObject*)rpcparam); /* rpcparam reference stolen by PyTuple_SET_ITEM */
call    0 never executed
        -:  823:
    #####:  824:                retcode = Parameter_dbrpcparam(rpcparam, dbproc, keystr);
call    0 never executed
        -:  825:            }
        -:  826:            while (0);
        -:  827:
    #####:  828:            Py_XDECREF(utf8key);
call    0 never executed
        -:  829:
    #####:  830:            if (PyErr_Occurred() || (FAIL == retcode))
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:  831:            {
        -:  832:                break;
        -:  833:            }
        -:  834:        }
        -:  835:    }
        -:  836:    else /* if (PyDict_Check(parameters)) */
        -:  837:    {
    #####:  838:        PyObject* key;
    #####:  839:        PyObject* value;
    #####:  840:        Py_ssize_t pos = 0;
        -:  841:
    #####:  842:        while (PyDict_Next(parameters, &pos, &key, &value))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  843:        {
    #####:  844:            struct Parameter* rpcparam = NULL;
    #####:  845:            PyObject* utf8key = NULL;
    #####:  846:            do
    #####:  847:            {
    #####:  848:                const char* keystr = Cursor_extract_parameter_name(key, &utf8key);
call    0 never executed
    #####:  849:                if (!keystr)
branch  0 never executed
branch  1 never executed
        -:  850:                {
    #####:  851:                    PyObject* repr = PyObject_Repr(key);
call    0 never executed
    #####:  852:                    if (repr)
branch  0 never executed
branch  1 never executed
        -:  853:                    {
        -:  854:#if PY_MAJOR_VERSION < 3
        -:  855:                        const char* reprstr = PyString_AS_STRING(repr);
        -:  856:#else /* if PY_MAJOR_VERSION < 3 */
    #####:  857:                        const char* reprstr = PyUnicode_AsUTF8(repr);
call    0 never executed
        -:  858:#endif /* else if PY_MAJOR_VERSION < 3 */
    #####:  859:                        PyErr_Format(PyExc_tds_InterfaceError, "invalid parameter name \"%s\"", reprstr);
call    0 never executed
    #####:  860:                        Py_DECREF(repr);
branch  0 never executed
branch  1 never executed
        -:  861:                    }
        -:  862:                    break;
        -:  863:                }
        -:  864:
    #####:  865:                if (!Parameter_Check(value))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  866:                {
    #####:  867:                    rpcparam = Parameter_create(value, 0 /* output */);
call    0 never executed
    #####:  868:                    if (!rpcparam)
branch  0 never executed
branch  1 never executed
        -:  869:                    {
        -:  870:                        break;
        -:  871:                    }
        -:  872:                }
        -:  873:                else
        -:  874:                {
    #####:  875:                    Py_INCREF(value);
branch  0 never executed
branch  1 never executed
        -:  876:                    rpcparam = (struct Parameter*)value;
        -:  877:                }
    #####:  878:                if (0 != Parameter_bind(rpcparam, dbproc))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  879:                {
        -:  880:                    break;
        -:  881:                }
        -:  882:
    #####:  883:                if (0 != PyDict_SetItem(rpcparams, key, (PyObject*)rpcparam))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  884:                {
        -:  885:                    break;
        -:  886:                }
        -:  887:
    #####:  888:                retcode = Parameter_dbrpcparam(rpcparam, dbproc, keystr);
    #####:  889:                if (FAIL == retcode)
call    0 never executed
        -:  890:                {
        -:  891:                    break;
        -:  892:                }
        -:  893:            }
        -:  894:            while (0);
        -:  895:
    #####:  896:            Py_XDECREF(utf8key);
call    0 never executed
    #####:  897:            Py_XDECREF(rpcparam);
call    0 never executed
        -:  898:
    #####:  899:            if (PyErr_Occurred() || (FAIL == retcode))
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:  900:            {
        -:  901:                break;
        -:  902:            }
        -:  903:        }
        -:  904:    }
    #####:  905:    if (FAIL == retcode)
branch  0 never executed
branch  1 never executed
        -:  906:    {
    #####:  907:        Connection_raise_lasterror(cursor->connection);
call    0 never executed
        -:  908:    }
        -:  909:
    #####:  910:    if (PyErr_Occurred())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  911:    {
    #####:  912:        Py_DECREF(rpcparams);
branch  0 never executed
branch  1 never executed
        -:  913:        rpcparams = NULL;
        -:  914:    }
        -:  915:
        -:  916:    return rpcparams;
        -:  917:}
        -:  918:
        -:  919:
        -:  920:struct OutputParameter
        -:  921:{
        -:  922:    const char* name;
        -:  923:    enum TdsType tdstype;
        -:  924:    const void* data;
        -:  925:    size_t ndata;
        -:  926:};
        -:  927:
        -:  928:
        -:  929:/*
        -:  930:    Unbind Python objects from RPC parameters after completion of an RPC call.
        -:  931:
        -:  932:    This method sets an appropriate Python exception on failure.
        -:  933:
        -:  934:    @note This method requires the current thread own the GIL.
        -:  935:    @note A new reference is returned.
        -:  936:
        -:  937:    @param cursor [in] A Cusor object.
        -:  938:    @param rpcparams [in] A Python dict or tuple object of bound parameters.
        -:  939:        These are assumed to all be instances of type `struct Parameter`.
        -:  940:    @param outputparams [in] The output parameters returned by the RPC call.
        -:  941:    @param noutputparams [in] The number of output parameters in `outputparams`.
        -:  942:    @param noutputs [out] The number of output parameters seen.
        -:  943:
        -:  944:    @return A Python dict or tuple object containg the result parameters.
        -:  945:*/
function Cursor_unbind called 0 returned 0% blocks executed 0%
    #####:  946:static PyObject* Cursor_unbind(PyObject* rpcparams,
        -:  947:                               const struct OutputParameter* outputparams,
        -:  948:                               size_t noutputparams, size_t* noutputs)
        -:  949:{
    #####:  950:    PyObject* results = NULL;
    #####:  951:    *noutputs = 0;
    #####:  952:    if (PyTuple_Check(rpcparams))
branch  0 never executed
branch  1 never executed
        -:  953:    {
    #####:  954:        Py_ssize_t ix;
    #####:  955:        Py_ssize_t nrpcparams = PyTuple_GET_SIZE(rpcparams);
call    0 never executed
    #####:  956:        results = PyTuple_New(nrpcparams);
call    0 never executed
    #####:  957:        if (!results)
branch  0 never executed
branch  1 never executed
        -:  958:        {
    #####:  959:            PyErr_NoMemory();
    #####:  960:            return NULL;
call    0 never executed
        -:  961:        }
        -:  962:
    #####:  963:        for (ix = 0; ix < nrpcparams; ++ix)
branch  0 never executed
branch  1 never executed
        -:  964:        {
    #####:  965:            PyObject* output = NULL;
    #####:  966:            struct Parameter* rpcparam = (struct Parameter*)PyTuple_GET_ITEM(rpcparams, ix);
    #####:  967:            if (Parameter_output(rpcparam))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  968:            {
    #####:  969:                if (*noutputs < noutputparams)
branch  0 never executed
branch  1 never executed
        -:  970:                {
    #####:  971:                    const struct OutputParameter* outputparam = &outputparams[*noutputs];
    #####:  972:                    sql_topython topython = sql_topython_lookup(outputparam->tdstype);
call    0 never executed
    #####:  973:                    assert(topython);
    #####:  974:                    output = topython(outputparam->tdstype,
    #####:  975:                                      outputparam->data,
    #####:  976:                                      outputparam->ndata);
call    0 never executed
        -:  977:                }
        -:  978:                else
        -:  979:                {
        -:  980:                    /*
        -:  981:                        If the parameter was not found, this is likely due to
        -:  982:                        the presence of a resultset. Return None for the
        -:  983:                        output parameter in this case.
        -:  984:                    */
    #####:  985:                    output = Py_None;
    #####:  986:                    Py_INCREF(output);
branch  0 never executed
branch  1 never executed
        -:  987:                }
    #####:  988:                ++(*noutputs);
        -:  989:            }
        -:  990:            else
        -:  991:            {
    #####:  992:                output = Parameter_value(rpcparam);
call    0 never executed
    #####:  993:                Py_INCREF(output);
branch  0 never executed
branch  1 never executed
        -:  994:            }
    #####:  995:            if (!output)
branch  0 never executed
branch  1 never executed
        -:  996:            {
        -:  997:                assert(PyErr_Occurred());
        -:  998:                break;
        -:  999:            }
    #####: 1000:            PyTuple_SET_ITEM(results, ix, output); /* output reference stolen by PyTuple_SET_ITEM */
        -: 1001:        }
        -: 1002:    }
        -: 1003:    else /* if (PyDict_Check(parameters)) */
        -: 1004:    {
    #####: 1005:        PyObject* key;
    #####: 1006:        PyObject* value;
    #####: 1007:        Py_ssize_t pos = 0;
        -: 1008:
    #####: 1009:        results = PyDict_New();
call    0 never executed
    #####: 1010:        if (!results)
branch  0 never executed
branch  1 never executed
        -: 1011:        {
    #####: 1012:            PyErr_NoMemory();
call    0 never executed
    #####: 1013:            return NULL;
        -: 1014:        }
        -: 1015:
    #####: 1016:        while (PyDict_Next(rpcparams, &pos, &key, &value))
branch  0 never executed
branch  1 never executed
        -: 1017:        {
    #####: 1018:            PyObject* output = NULL;
    #####: 1019:            struct Parameter* rpcparam = (struct Parameter*)value;
    #####: 1020:            if (Parameter_output(rpcparam))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1021:            {
    #####: 1022:                const struct OutputParameter* outputparam = NULL;
    #####: 1023:                const char* name;
    #####: 1024:                size_t ix;
        -: 1025:#if PY_MAJOR_VERSION < 3
        -: 1026:                PyObject* utf8key;
        -: 1027:                if (PyUnicode_Check(key))
        -: 1028:                {
        -: 1029:                    utf8key = PyUnicode_AsUTF8String(key);
        -: 1030:                    if (!utf8key)
        -: 1031:                    {
        -: 1032:                        break;
        -: 1033:                    }
        -: 1034:                }
        -: 1035:                else
        -: 1036:                {
        -: 1037:                    assert(PyString_Check(key));
        -: 1038:                    Py_INCREF(key);
        -: 1039:                    utf8key = key;
        -: 1040:                }
        -: 1041:                name = PyString_AS_STRING(utf8key);
        -: 1042:#else /* if PY_MAJOR_VERSION < 3 */
    #####: 1043:                name = PyUnicode_AsUTF8(key);
        -: 1044:#endif /* else if PY_MAJOR_VERSION < 3 */
    #####: 1045:                for (ix = 0; ix < noutputparams; ++ix)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1046:                {
    #####: 1047:                    if (strcmp(name, outputparams[ix].name) == 0)
branch  0 never executed
branch  1 never executed
        -: 1048:                    {
        -: 1049:                        outputparam = &outputparams[ix];
        -: 1050:                        break;
        -: 1051:                    }
        -: 1052:                }
        -: 1053:#if PY_MAJOR_VERSION < 3
        -: 1054:                Py_DECREF(utf8key);
        -: 1055:#endif /* if PY_MAJOR_VERSION < 3 */
    #####: 1056:                if (outputparam)
branch  0 never executed
branch  1 never executed
        -: 1057:                {
    #####: 1058:                    sql_topython topython = sql_topython_lookup(outputparam->tdstype);
call    0 never executed
    #####: 1059:                    assert(topython);
    #####: 1060:                    output = topython(outputparam->tdstype,
    #####: 1061:                                      outputparam->data,
    #####: 1062:                                      outputparam->ndata);
call    0 never executed
        -: 1063:                }
        -: 1064:                else
        -: 1065:                {
        -: 1066:                    /*
        -: 1067:                        If the parameter was not found, this is likely due to
        -: 1068:                        the presence of a resultset. Return None for the
        -: 1069:                        output parameter in this case.
        -: 1070:                    */
    #####: 1071:                    output = Py_None;
    #####: 1072:                    Py_INCREF(output);
branch  0 never executed
branch  1 never executed
        -: 1073:                }
    #####: 1074:                ++(*noutputs);
        -: 1075:            }
        -: 1076:            else
        -: 1077:            {
    #####: 1078:                output = Parameter_value(rpcparam);
call    0 never executed
    #####: 1079:                Py_INCREF(output);
branch  0 never executed
branch  1 never executed
        -: 1080:            }
    #####: 1081:            if (!output)
branch  0 never executed
branch  1 never executed
        -: 1082:            {
        -: 1083:                assert(PyErr_Occurred());
        -: 1084:                break;
        -: 1085:            }
    #####: 1086:            (void)PyDict_SetItem(results, key, output);
call    0 never executed
    #####: 1087:            Py_DECREF(output);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1088:        }
        -: 1089:    }
        -: 1090:
    #####: 1091:    if (PyErr_Occurred())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1092:    {
    #####: 1093:        Py_DECREF(results);
branch  0 never executed
branch  1 never executed
        -: 1094:        results = NULL;
        -: 1095:    }
        -: 1096:
        -: 1097:    return results;
        -: 1098:}
        -: 1099:
        -: 1100:/*
        -: 1101:    Bind input arguments to their SQL types, call a stored procedure, and
        -: 1102:    process the resulting output values.
        -: 1103:
        -: 1104:    @note This does not check the cursor state (i.e. open, connected).
        -: 1105:
        -: 1106:    @param cursor [in] The Cursor.
        -: 1107:    @param procname [in] The stored procedure name, UTF-8 encoded.
        -: 1108:    @param parameters [in] A Python dict or tuple containing the parameters
        -: 1109:        to the stored procedure. The arguments can be of any Python type.
        -: 1110:    @param kvpairs [in] Are the parameters passed as (key, value) pairs?
        -: 1111:        This is necessary to support ordered named parameters.
        -: 1112:
        -: 1113:    @return A copy of the input arguments, including any output parameters in
        -: 1114:        place.
        -: 1115:*/
function Cursor_callproc_internal called 0 returned 0% blocks executed 0%
    #####: 1116:static PyObject* Cursor_callproc_internal(struct Cursor* cursor, const char* procname,
        -: 1117:                                          PyObject* parameters, bool kvpairs)
        -: 1118:{
    #####: 1119:    PyObject* results = NULL;
        -: 1120:
    #####: 1121:    PyObject* rpcparams = NULL;
    #####: 1122:    struct OutputParameter* outputparams = NULL;
    #####: 1123:    DBINT retstatus;
        -: 1124:
    #####: 1125:    Connection_clear_lastwarning(cursor->connection);
call    0 never executed
        -: 1126:
    #####: 1127:    do
    #####: 1128:    {
    #####: 1129:        DBPROCESS* dbproc = Connection_DBPROCESS(cursor->connection);
call    0 never executed
        -: 1130:
    #####: 1131:        int error = -1;
    #####: 1132:        RETCODE retcode;
        -: 1133:
    #####: 1134:        int noutputparams = 0;
    #####: 1135:        size_t noutputs;
        -: 1136:
    #####: 1137:        if (FAIL == dbrpcinit(dbproc, procname, 0 /* options */))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1138:        {
    #####: 1139:            Connection_raise_lasterror(cursor->connection);
    #####: 1140:            break;
call    0 never executed
        -: 1141:        }
        -: 1142:
    #####: 1143:        rpcparams = Cursor_bind(cursor, parameters, kvpairs);
call    0 never executed
    #####: 1144:        if (!rpcparams)
branch  0 never executed
branch  1 never executed
        -: 1145:        {
        -: 1146:            /* Clear the RPC call initialization if it fails to send. */
    #####: 1147:            (void)dbrpcinit(dbproc, procname, DBRPCRESET);
    #####: 1148:            break;
call    0 never executed
        -: 1149:        }
        -: 1150:
    #####: 1151:        Cursor_clear_resultset(cursor);
branch  0 never executed
branch  1 never executed
        -: 1152:
    #####: 1153:        Py_BEGIN_ALLOW_THREADS
call    0 never executed
        -: 1154:
    #####: 1155:            do
    #####: 1156:            {
    #####: 1157:                retcode = dbcancel(dbproc);
call    0 never executed
    #####: 1158:                if (FAIL == retcode)
branch  0 never executed
branch  1 never executed
        -: 1159:                {
        -: 1160:                    break;
        -: 1161:                }
    #####: 1162:                retcode = dbrpcsend(dbproc);
call    0 never executed
    #####: 1163:                if (FAIL == retcode)
branch  0 never executed
branch  1 never executed
        -: 1164:                {
        -: 1165:                    break;
        -: 1166:                }
    #####: 1167:                retcode = dbsqlok(dbproc);
call    0 never executed
    #####: 1168:                if (FAIL == retcode)
branch  0 never executed
branch  1 never executed
        -: 1169:                {
        -: 1170:                    break;
        -: 1171:                }
        -: 1172:
    #####: 1173:                error = Cursor_next_resultset(cursor, &retcode);
call    0 never executed
    #####: 1174:                if (!error)
branch  0 never executed
branch  1 never executed
        -: 1175:                {
    #####: 1176:                    noutputparams = dbnumrets(dbproc);
call    0 never executed
        -: 1177:
    #####: 1178:                    if (noutputparams)
branch  0 never executed
branch  1 never executed
        -: 1179:                    {
    #####: 1180:                        int ix;
        -: 1181:
    #####: 1182:                        outputparams = tds_mem_calloc((size_t)noutputparams, sizeof(struct OutputParameter));
    #####: 1183:                        if (!outputparams)
branch  0 never executed
branch  1 never executed
        -: 1184:                        {
        -: 1185:                            break;
        -: 1186:                        }
        -: 1187:
    #####: 1188:                        for (ix = 0; ix < noutputparams; ++ix)
branch  0 never executed
branch  1 never executed
        -: 1189:                        {
    #####: 1190:                            outputparams[ix].name = (const char*)dbretname(dbproc, ix + 1);
call    0 never executed
    #####: 1191:                            outputparams[ix].tdstype = (enum TdsType)dbrettype(dbproc, ix + 1);
call    0 never executed
    #####: 1192:                            outputparams[ix].data = (const void*)dbretdata(dbproc, ix + 1);
call    0 never executed
    #####: 1193:                            outputparams[ix].ndata = (size_t)dbretlen(dbproc, ix + 1);
call    0 never executed
        -: 1194:                        }
        -: 1195:                    }
    #####: 1196:                    retstatus = dbretstatus(dbproc);
call    0 never executed
        -: 1197:                }
        -: 1198:            } while (0);
        -: 1199:
    #####: 1200:        Py_END_ALLOW_THREADS
call    0 never executed
        -: 1201:
    #####: 1202:        if (FAIL == retcode)
branch  0 never executed
branch  1 never executed
        -: 1203:        {
    #####: 1204:            Connection_raise_lasterror(cursor->connection);
    #####: 1205:            break;
call    0 never executed
        -: 1206:        }
    #####: 1207:        if (error)
branch  0 never executed
branch  1 never executed
        -: 1208:        {
    #####: 1209:            assert(FAIL != retcode);
    #####: 1210:            PyErr_NoMemory();
    #####: 1211:            break;
call    0 never executed
        -: 1212:        }
        -: 1213:
    #####: 1214:        results = Cursor_unbind(rpcparams,
call    0 never executed
        -: 1215:                                outputparams,
        -: 1216:                                (size_t)noutputparams,
        -: 1217:                                &noutputs);
    #####: 1218:        if ((NULL != results) && (noutputs > 0) && (NO_MORE_RESULTS != retcode))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1219:        {
        -: 1220:            /*
        -: 1221:                TDS returns output parameter data (and status) only after all
        -: 1222:                resultsets have been read. This is inherently incompatible with
        -: 1223:                the DB API 2.0 interface. If an attempt is made to use the API
        -: 1224:                in this way, return the resultsets and raise a warning.
        -: 1225:            */
    #####: 1226:            if (0 != PyErr_WarnEx(PyExc_Warning,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1227:                                  "output parameters are not supported with result sets",
        -: 1228:                                  1))
        -: 1229:            {
    #####: 1230:                Py_DECREF(results);
branch  0 never executed
branch  1 never executed
        -: 1231:                results = NULL;
        -: 1232:                break;
        -: 1233:            }
        -: 1234:        }
        -: 1235:    } while (0);
        -: 1236:
    #####: 1237:    if (!PyErr_Occurred())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1238:    {
    #####: 1239:        if (0 != Connection_raise_lastwarning(cursor->connection))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1240:        {
    #####: 1241:            assert(PyErr_Occurred());
    #####: 1242:            Py_DECREF(results);
branch  0 never executed
branch  1 never executed
        -: 1243:            results = NULL;
        -: 1244:        }
        -: 1245:    }
        -: 1246:
    #####: 1247:    tds_mem_free(outputparams);
        -: 1248:
    #####: 1249:    Py_XDECREF(rpcparams);
call    0 never executed
        -: 1250:
    #####: 1251:    return results;
        -: 1252:
        -: 1253:    /* $TODO: figure out some way to expose the sproc return status. */
    #####: 1254:    UNUSED(retstatus);
        -: 1255:}
        -: 1256:
        -: 1257:/* https://www.python.org/dev/peps/pep-0249/#callproc */
        -: 1258:static const char s_Cursor_callproc_doc[] =
        -: 1259:    "callproc(sproc, parameters)\n"
        -: 1260:    "\n"
        -: 1261:    "Call a stored database procedure with the given name. The sequence of\n"
        -: 1262:    "parameters must contain one entry for each argument that the procedure\n"
        -: 1263:    "expects. The result of the call is returned as modified copy of the input\n"
        -: 1264:    "sequence. Input parameters are left untouched. Output and input/output\n"
        -: 1265:    "parameters are replaced with output values.\n"
        -: 1266:    "\n"
        -: 1267:    ".. warning:: Due to `FreeTDS` implementation details, stored procedures\n"
        -: 1268:    "    with both output parameters and resultsets are not supported.\n"
        -: 1269:    "\n"
        -: 1270:    ".. warning:: Currently `FreeTDS` does not support passing empty string\n"
        -: 1271:    "    parameters. Empty strings are converted to `NULL` values internally\n"
        -: 1272:    "    before being transmitted to the database.\n"
        -: 1273:    "\n"
        -: 1274:    ":pep:`0249#callproc`\n"
        -: 1275:    "\n"
        -: 1276:    ":param str sproc: The name of the stored procedure to execute.\n"
        -: 1277:
        -: 1278:    ":param parameters: Parameters to pass to the stored procedure.\n"
        -: 1279:    "    Parameters passed in a :py:class:`dict` must map from the parameter\n"
        -: 1280:    "    name to value and start with the **@** character. Parameters passed\n"
        -: 1281:    "    in a :py:class:`tuple` are passed in the tuple order.\n"
        -: 1282:    ":type parameters: dict or tuple\n"
        -: 1283:
        -: 1284:    ":return: The input `parameters` with any output parameters replaced with\n"
        -: 1285:    "    the output values.\n"
        -: 1286:    ":rtype: dict or tuple\n";
        -: 1287:
function Cursor_callproc called 0 returned 0% blocks executed 0%
    #####: 1288:static PyObject* Cursor_callproc(PyObject* self, PyObject* args)
        -: 1289:{
    #####: 1290:    struct Cursor* cursor = (struct Cursor*)self;
        -: 1291:
    #####: 1292:    char* procname = NULL;
    #####: 1293:    PyObject* parameters = NULL;
    #####: 1294:    if (!PyArg_ParseTuple(args, "sO", &procname, &parameters))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1295:    {
        -: 1296:        return NULL;
        -: 1297:    }
        -: 1298:    /*
        -: 1299:        Allow either a tuple or dictionary for the stored procedure arguments.
        -: 1300:        Note that this is a deviation from the DB API 2.0 specification.
        -: 1301:    */
    #####: 1302:    if (!PyDict_Check(parameters) && !PyTuple_Check(parameters))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1303:    {
    #####: 1304:        PyErr_SetString(PyExc_TypeError, "must be dict or tuple");
    #####: 1305:        return NULL;
call    0 never executed
        -: 1306:    }
        -: 1307:
    #####: 1308:    Cursor_verify_open(cursor);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1309:    Cursor_verify_connection_open(cursor);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1310:
    #####: 1311:    return Cursor_callproc_internal(cursor, procname, parameters, false);
call    0 never executed
        -: 1312:}
        -: 1313:
        -: 1314:/* https://www.python.org/dev/peps/pep-0249/#Cursor.close */
        -: 1315:static const char s_Cursor_close_doc[] =
        -: 1316:    "close()\n"
        -: 1317:    "\n"
        -: 1318:    "Close the cursor.\n"
        -: 1319:    "\n"
        -: 1320:    ":pep:`0249#Cursor.close`\n";
        -: 1321:
function Cursor_close called 0 returned 0% blocks executed 0%
    #####: 1322:static PyObject* Cursor_close(PyObject* self, PyObject* args)
        -: 1323:{
    #####: 1324:    struct Cursor* cursor = (struct Cursor*)self;
        -: 1325:
    #####: 1326:    Cursor_verify_open(cursor);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1327:
    #####: 1328:    Cursor_close_connection(cursor);
        -: 1329:
    #####: 1330:    Py_RETURN_NONE;
call    0 never executed
    #####: 1331:    UNUSED(args);
        -: 1332:}
        -: 1333:
        -: 1334:
        -: 1335:/*
        -: 1336:    Append one string to an existing one by reallocating the existing string.
        -: 1337:    This will free the existing string if the reallocation fails.
        -: 1338:*/
function strappend called 0 returned 0% blocks executed 0%
    #####: 1339:static char* strappend(char* existing, size_t nexisting, const char* suffix, size_t nsuffix)
        -: 1340:{
    #####: 1341:    char* tmp = (char*)tds_mem_realloc(existing, nexisting + nsuffix + 1 /* '\0' */);
    #####: 1342:    if (tmp)
branch  0 never executed
branch  1 never executed
        -: 1343:    {
    #####: 1344:        memcpy(tmp + nexisting, suffix, nsuffix);
    #####: 1345:        tmp[nexisting + nsuffix] = '\0';
        -: 1346:    }
        -: 1347:    else
        -: 1348:    {
    #####: 1349:        tds_mem_free(existing);
        -: 1350:    }
    #####: 1351:    return tmp;
        -: 1352:}
        -: 1353:
        -: 1354:
        -: 1355:/*
        -: 1356:    Generate a SQL statement suitable for use as the `@stmt` parameter to
        -: 1357:    sp_executesql or format the SQL statement for direct execution.
        -: 1358:
        -: 1359:    @param format [in] The SQL command format string.
        -: 1360:    @param paramstyle [in] The paramstyle used in the format string.
        -: 1361:    @param parameters [in] The parameters available.
        -: 1362:    @param nparameters [in] The number of parameters available.
        -: 1363:    @param maximum_width [in] Generate types with MAX width for variable width types.
        -: 1364:    @param nsql [out] The length of the generated SQL string, in bytes.
        -: 1365:
        -: 1366:    @return The utf-8 formatted SQL statement. The caller is responsible freeing the returned value.
        -: 1367:*/
function build_executesql_stmt called 0 returned 0% blocks executed 0%
    #####: 1368:static char* build_executesql_stmt(DBPROCESS* dbproc,
        -: 1369:                                   const char* format,
        -: 1370:                                   enum ParamStyle paramstyle,
        -: 1371:                                   PyObject* parameters,
        -: 1372:                                   Py_ssize_t nparameters,
        -: 1373:                                   bool maximum_width,
        -: 1374:                                   size_t* nsql)
        -: 1375:{
    #####: 1376:    char* sql = NULL;
    #####: 1377:    *nsql = 0;
    #####: 1378:    do
    #####: 1379:    {
    #####: 1380:        bool literal = false; /* currently in a string literal? */
        -: 1381:
        -: 1382:        /* Construct the SQL query string. */
    #####: 1383:        const char* chunk = format; /* the start of the next chunk to copy */
    #####: 1384:        size_t nchunk = 0;
    #####: 1385:        while ('\0' != *format)
branch  0 never executed
branch  1 never executed
        -: 1386:        {
        -: 1387:            /* \' characters can only be escaped in string literals. */
    #####: 1388:            if ('\'' == *format)
branch  0 never executed
branch  1 never executed
        -: 1389:            {
    #####: 1390:                literal = !literal;
    #####: 1391:                format++;
        -: 1392:            }
    #####: 1393:            else if (!literal && (':' == *format))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1394:            {
    #####: 1395:                char* param = NULL;
    #####: 1396:                size_t nparam = 0;
        -: 1397:
    #####: 1398:                do
    #####: 1399:                {
    #####: 1400:                    long int paramnum = -1;
    #####: 1401:                    const char* parammarker_start = format + 1; /* skip over the ':' */
    #####: 1402:                    char* parammarker_end = (char*)parammarker_start;
        -: 1403:
        -: 1404:#if !defined(CTDS_USE_SP_EXECUTESQL)
        -: 1405:                    PyObject* oparam = NULL;
        -: 1406:#endif /* !defined(CTDS_USE_SP_EXECUTESQL) */
        -: 1407:
    #####: 1408:                    nchunk = (size_t)(format - chunk);
        -: 1409:
        -: 1410:                    /* Append the prior chunk. */
    #####: 1411:                    sql = strappend(sql, *nsql, chunk, nchunk);
call    0 never executed
    #####: 1412:                    if (!sql)
branch  0 never executed
branch  1 never executed
        -: 1413:                    {
    #####: 1414:                        PyErr_NoMemory();
    #####: 1415:                        break;
call    0 never executed
        -: 1416:                    }
        -: 1417:
    #####: 1418:                    if (ParamStyle_numeric == paramstyle)
branch  0 never executed
branch  1 never executed
        -: 1419:                    {
    #####: 1420:                        paramnum = strtol(parammarker_start, &parammarker_end, 10);
call    0 never executed
    #####: 1421:                        if (parammarker_start == parammarker_end)
branch  0 never executed
branch  1 never executed
        -: 1422:                        {
        -: 1423:                            /* Missing the index following the parameter marker. */
    #####: 1424:                            PyErr_Format(PyExc_tds_InterfaceError, "invalid parameter marker");
    #####: 1425:                            break;
call    0 never executed
        -: 1426:                        }
    #####: 1427:                        if ((0 > paramnum) || (paramnum >= nparameters))
branch  0 never executed
branch  1 never executed
        -: 1428:                        {
    #####: 1429:                            PyErr_Format(PyExc_IndexError, "%ld", paramnum);
    #####: 1430:                            break;
call    0 never executed
        -: 1431:                        }
        -: 1432:                    }
        -: 1433:                    else
        -: 1434:                    {
        -: 1435:                        assert(ParamStyle_named == paramstyle);
    #####: 1436:                        while (isalnum(*parammarker_end) || '_' == *parammarker_end)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1437:                        {
    #####: 1438:                            ++parammarker_end;
        -: 1439:                        }
        -: 1440:                    }
        -: 1441:
        -: 1442:#if defined(CTDS_USE_SP_EXECUTESQL)
    #####: 1443:                    if (ParamStyle_numeric == paramstyle)
branch  0 never executed
branch  1 never executed
        -: 1444:                    {
    #####: 1445:                        param = tds_mem_malloc(ARRAYSIZE("@param" STRINGIFY(UINT64_MAX)));
    #####: 1446:                        if (param)
branch  0 never executed
branch  1 never executed
        -: 1447:                        {
    #####: 1448:                            assert(-1 != paramnum);
    #####: 1449:                            nparam = (size_t)sprintf(param, "@param%u", (unsigned int)paramnum);
        -: 1450:                        }
        -: 1451:                        UNUSED(parameters);
        -: 1452:                    }
        -: 1453:                    else
        -: 1454:                    {
    #####: 1455:                        assert(parammarker_end >= parammarker_start);
    #####: 1456:                        nparam = 1 /* @ */ + (size_t)(parammarker_end - parammarker_start);
    #####: 1457:                        param = tds_mem_malloc(nparam + 1 /* '\0' */);
    #####: 1458:                        if (param)
branch  0 never executed
branch  1 never executed
        -: 1459:                        {
    #####: 1460:                            char* paramname;
    #####: 1461:                            param[0] = '@';
    #####: 1462:                            memcpy(param + 1, parammarker_start, (size_t)(parammarker_end - parammarker_start));
    #####: 1463:                            param[nparam] = '\0';
        -: 1464:
    #####: 1465:                            paramname = param + 1;
        -: 1466:
    #####: 1467:                            if (!PyMapping_HasKeyString(parameters, paramname))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1468:                            {
    #####: 1469:                                PyErr_Format(PyExc_LookupError, "unknown named parameter \"%s\"", paramname);
    #####: 1470:                                break;
call    0 never executed
        -: 1471:                            }
        -: 1472:                        }
        -: 1473:                    }
        -: 1474:
    #####: 1475:                    if (!param)
branch  0 never executed
branch  1 never executed
        -: 1476:                    {
    #####: 1477:                        PyErr_NoMemory();
    #####: 1478:                        break;
call    0 never executed
        -: 1479:                    }
        -: 1480:
    #####: 1481:                    UNUSED(maximum_width);
    #####: 1482:                    UNUSED(dbproc);
        -: 1483:
        -: 1484:#else /* if defined(CTDS_USE_SP_EXECUTESQL) */
        -: 1485:                    /* Serialize the parameter to a string. */
        -: 1486:                    do
        -: 1487:                    {
        -: 1488:                        PyObject* item = NULL;
        -: 1489:                        if (ParamStyle_numeric == paramstyle)
        -: 1490:                        {
        -: 1491:                            item = PySequence_GetItem(parameters, paramnum);
        -: 1492:                        }
        -: 1493:                        else
        -: 1494:                        {
        -: 1495:                            size_t nparamname = (size_t)(parammarker_end - parammarker_start);
        -: 1496:                            char* paramname = tds_mem_malloc(nparamname + 1 /* '\0' */);
        -: 1497:                            if (!paramname)
        -: 1498:                            {
        -: 1499:                                PyErr_NoMemory();
        -: 1500:                                break;
        -: 1501:                            }
        -: 1502:                            strncpy(paramname, parammarker_start, nparamname);
        -: 1503:                            paramname[nparamname] = '\0';
        -: 1504:                            item = PyMapping_GetItemString(parameters, paramname);
        -: 1505:                            if (!item)
        -: 1506:                            {
        -: 1507:                                PyErr_Format(PyExc_LookupError, "unknown named parameter \"%s\"", paramname);
        -: 1508:                            }
        -: 1509:                            tds_mem_free(paramname);
        -: 1510:
        -: 1511:                            if (PyErr_Occurred())
        -: 1512:                            {
        -: 1513:                                break;
        -: 1514:                            }
        -: 1515:                        }
        -: 1516:
        -: 1517:                        if (!Parameter_Check(item))
        -: 1518:                        {
        -: 1519:                            oparam = (PyObject*)Parameter_create(item, 0 /* output */);
        -: 1520:                        }
        -: 1521:                        else
        -: 1522:                        {
        -: 1523:                            Py_INCREF(item);
        -: 1524:                            oparam = item;
        -: 1525:                        }
        -: 1526:                        Py_DECREF(item);
        -: 1527:
        -: 1528:                        if (!oparam)
        -: 1529:                        {
        -: 1530:                            break;
        -: 1531:                        }
        -: 1532:
        -: 1533:                        if (0 != Parameter_bind((struct Parameter*)oparam, dbproc))
        -: 1534:                        {
        -: 1535:                            break;
        -: 1536:                        }
        -: 1537:
        -: 1538:                        param = Parameter_serialize((struct Parameter*)oparam, maximum_width, &nparam);
        -: 1539:                        if (!param)
        -: 1540:                        {
        -: 1541:                            break;
        -: 1542:                        }
        -: 1543:                    }
        -: 1544:                    while (0);
        -: 1545:
        -: 1546:                    Py_XDECREF(oparam);
        -: 1547:
        -: 1548:                    if (PyErr_Occurred())
        -: 1549:                    {
        -: 1550:                        break;
        -: 1551:                    }
        -: 1552:#endif /* else if defined(CTDS_USE_SP_EXECUTESQL) */
        -: 1553:
    #####: 1554:                    *nsql += nchunk;
    #####: 1555:                    nchunk = 0;
        -: 1556:
    #####: 1557:                    format = chunk = parammarker_end;
        -: 1558:
    #####: 1559:                    sql = strappend(sql, *nsql, param, nparam);
call    0 never executed
    #####: 1560:                    if (!sql)
branch  0 never executed
branch  1 never executed
        -: 1561:                    {
    #####: 1562:                        PyErr_NoMemory();
    #####: 1563:                        break;
call    0 never executed
        -: 1564:                    }
    #####: 1565:                    *nsql += nparam;
        -: 1566:                }
        -: 1567:                while (0);
        -: 1568:
    #####: 1569:                tds_mem_free(param);
        -: 1570:
    #####: 1571:                if (PyErr_Occurred())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1572:                {
        -: 1573:                    break;
        -: 1574:                }
        -: 1575:            }
        -: 1576:            else
        -: 1577:            {
    #####: 1578:                format++;
        -: 1579:            }
        -: 1580:        }
        -: 1581:
    #####: 1582:        if (PyErr_Occurred())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1583:        {
        -: 1584:            break;
        -: 1585:        }
        -: 1586:
        -: 1587:        /* Append the last chunk. */
    #####: 1588:        nchunk = (size_t)(format - chunk);
    #####: 1589:        sql = strappend(sql, *nsql, chunk, nchunk);
call    0 never executed
    #####: 1590:        *nsql += nchunk;
    #####: 1591:        if (!sql)
branch  0 never executed
branch  1 never executed
        -: 1592:        {
    #####: 1593:            PyErr_NoMemory();
    #####: 1594:            break;
call    0 never executed
        -: 1595:        }
        -: 1596:    } while (0);
        -: 1597:
    #####: 1598:    if (PyErr_Occurred())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1599:    {
    #####: 1600:        tds_mem_free(sql);
    #####: 1601:        sql = NULL;
        -: 1602:    }
        -: 1603:
    #####: 1604:    return sql;
        -: 1605:}
        -: 1606:
        -: 1607:
        -: 1608:/*
        -: 1609:    Execute a raw SQL statement and fetch the first result set.
        -: 1610:
        -: 1611:    @note This does not check the cursor state (i.e. open, connected).
        -: 1612:
        -: 1613:    @param cursor [in] The Cursor.
        -: 1614:    @param sqlfmt [in] A SQL string to execute.
        -: 1615:
        -: 1616:    @return 0 on success, -1 on error.
        -: 1617:*/
function Cursor_execute_sql called 0 returned 0% blocks executed 0%
    #####: 1618:static int Cursor_execute_sql(struct Cursor* cursor, const char* sql)
        -: 1619:{
    #####: 1620:    do
    #####: 1621:    {
    #####: 1622:        bool error = false;
        -: 1623:
    #####: 1624:        DBPROCESS* dbproc = Connection_DBPROCESS(cursor->connection);
call    0 never executed
    #####: 1625:        RETCODE retcode;
        -: 1626:
    #####: 1627:        Connection_clear_lastwarning(cursor->connection);
call    0 never executed
        -: 1628:
        -: 1629:        /* Clear any existing command buffer. */
    #####: 1630:        dbfreebuf(dbproc);
call    0 never executed
        -: 1631:
    #####: 1632:        retcode = dbcmd(dbproc, sql);
call    0 never executed
    #####: 1633:        if (FAIL == retcode)
branch  0 never executed
branch  1 never executed
        -: 1634:        {
    #####: 1635:            Connection_raise_lasterror(cursor->connection);
    #####: 1636:            break;
call    0 never executed
        -: 1637:        }
        -: 1638:
    #####: 1639:        Cursor_clear_resultset(cursor);
branch  0 never executed
branch  1 never executed
        -: 1640:
    #####: 1641:        Py_BEGIN_ALLOW_THREADS
call    0 never executed
        -: 1642:
    #####: 1643:            do
    #####: 1644:            {
    #####: 1645:                retcode = dbcancel(dbproc);
call    0 never executed
    #####: 1646:                if (FAIL == retcode)
branch  0 never executed
branch  1 never executed
        -: 1647:                {
        -: 1648:                    break;
        -: 1649:                }
    #####: 1650:                retcode = dbsqlsend(dbproc);
call    0 never executed
    #####: 1651:                if (FAIL == retcode)
branch  0 never executed
branch  1 never executed
        -: 1652:                {
        -: 1653:                    break;
        -: 1654:                }
    #####: 1655:                retcode = dbsqlok(dbproc);
call    0 never executed
    #####: 1656:                if (FAIL == retcode)
branch  0 never executed
branch  1 never executed
        -: 1657:                {
        -: 1658:                    break;
        -: 1659:                }
        -: 1660:
    #####: 1661:                error = (0 != Cursor_next_resultset(cursor, &retcode));
call    0 never executed
        -: 1662:            } while (0);
        -: 1663:
    #####: 1664:        Py_END_ALLOW_THREADS
call    0 never executed
        -: 1665:
    #####: 1666:        if (FAIL == retcode)
branch  0 never executed
branch  1 never executed
        -: 1667:        {
    #####: 1668:            Connection_raise_lasterror(cursor->connection);
    #####: 1669:            break;
call    0 never executed
        -: 1670:        }
    #####: 1671:        if (error)
branch  0 never executed
branch  1 never executed
        -: 1672:        {
    #####: 1673:            assert(FAIL != retcode);
    #####: 1674:            PyErr_NoMemory();
    #####: 1675:            break;
call    0 never executed
        -: 1676:        }
        -: 1677:
        -: 1678:        /* Raise any warnings that may have occurred. */
    #####: 1679:        if (0 != Connection_raise_lastwarning(cursor->connection))
call    0 never executed
        -: 1680:        {
        -: 1681:            assert(PyErr_Occurred());
        -: 1682:            break;
        -: 1683:        }
        -: 1684:    }
        -: 1685:    while (0);
        -: 1686:
    #####: 1687:    return (PyErr_Occurred()) ? -1 : 0;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1688:}
        -: 1689:
        -: 1690:
        -: 1691:#if defined(CTDS_USE_SP_EXECUTESQL)
        -: 1692:
        -: 1693:/*
        -: 1694:    Generate a parameter name to use with `sp_executesql` from
        -: 1695:    the given Python string object. E.g. "@MyParameter"
        -: 1696:
        -: 1697:    @note The caller must free the returned value with `tds_mem_free`.
        -: 1698:
        -: 1699:    @param oname [in] A Python Unicode (or String) object.
        -: 1700:    @param nparamname [out] The length of the returned string.
        -: 1701:
        -: 1702:    @return A pointer to the utf-8 encoded name, or NULL on failure.
        -: 1703:*/
function make_paramname called 0 returned 0% blocks executed 0%
    #####: 1704:static char* make_paramname(PyObject* oname, size_t* nparamname)
        -: 1705:{
    #####: 1706:    char* paramname = NULL;
    #####: 1707:    int written;
        -: 1708:
    #####: 1709:    PyObject* oparamname = NULL;
        -: 1710:
    #####: 1711:    const char* name;
    #####: 1712:    size_t nname;
    #####: 1713:    do
    #####: 1714:    {
    #####: 1715:        size_t required;
        -: 1716:#if PY_MAJOR_VERSION < 3
        -: 1717:        if (PyUnicode_Check(oname))
        -: 1718:        {
        -: 1719:            oparamname = PyUnicode_AsUTF8String(oname);
        -: 1720:            if (!oparamname)
        -: 1721:            {
        -: 1722:                break;
        -: 1723:            }
        -: 1724:        }
        -: 1725:        else if (PyString_CheckExact(oname))
        -: 1726:        {
        -: 1727:            Py_INCREF(oname);
        -: 1728:            oparamname = oname;
        -: 1729:        }
        -: 1730:        else
        -: 1731:        {
        -: 1732:            PyErr_SetObject(PyExc_TypeError, oname);
        -: 1733:            break;
        -: 1734:        }
        -: 1735:
        -: 1736:        nname = (size_t)PyString_GET_SIZE(oparamname);
        -: 1737:        name = PyString_AS_STRING(oparamname);
        -: 1738:#else /* if PY_MAJOR_VERSION < 3 */
    #####: 1739:        Py_ssize_t size;
    #####: 1740:        if (!PyUnicode_Check(oname))
branch  0 never executed
branch  1 never executed
        -: 1741:        {
    #####: 1742:            PyErr_SetObject(PyExc_TypeError, oname);
    #####: 1743:            break;
call    0 never executed
        -: 1744:        }
    #####: 1745:        name = PyUnicode_AsUTF8AndSize(oname, &size);
call    0 never executed
    #####: 1746:        if (!name)
branch  0 never executed
branch  1 never executed
        -: 1747:        {
        -: 1748:            break;
        -: 1749:        }
    #####: 1750:        nname = (size_t)size;
        -: 1751:#endif /* else if PY_MAJOR_VERSION < 3 */
        -: 1752:
    #####: 1753:        required = nname + 1 /* '@' */ + 1 /* '\0' */;
    #####: 1754:        paramname = tds_mem_malloc(required);
    #####: 1755:        if (!paramname)
branch  0 never executed
branch  1 never executed
        -: 1756:        {
    #####: 1757:            PyErr_NoMemory();
    #####: 1758:            break;
call    0 never executed
        -: 1759:        }
        -: 1760:
    #####: 1761:        written = PyOS_snprintf(paramname, required, "@%s", name);
call    0 never executed
    #####: 1762:        assert((size_t)written == (required - 1));
        -: 1763:
    #####: 1764:        if (nparamname)
branch  0 never executed
branch  1 never executed
        -: 1765:        {
    #####: 1766:            *nparamname = (size_t)written;
        -: 1767:        }
        -: 1768:    }
        -: 1769:    while (0);
        -: 1770:
    #####: 1771:    Py_XDECREF(oparamname);
call    0 never executed
        -: 1772:
    #####: 1773:    return paramname;
        -: 1774:}
        -: 1775:
        -: 1776:/*
        -: 1777:    Generate a params string suitable for use as the `@params` parameter to
        -: 1778:    sp_executesql.
        -: 1779:
        -: 1780:    @param paramstyle [in] The paramstyle, indicating whether a mapping or sequence is expected.
        -: 1781:    @param parameters [in] A Python sequence or mapping of parameters.
        -: 1782:    @param maximum_width [in] Generate types with MAX width for variable width types.
        -: 1783:
        -: 1784:    @return A new reference to a Python string object.
        -: 1785:*/
function build_executesql_params called 0 returned 0% blocks executed 0%
    #####: 1786:static PyObject* build_executesql_params(DBPROCESS* dbproc,
        -: 1787:                                         enum ParamStyle paramstyle,
        -: 1788:                                         PyObject* parameters,
        -: 1789:                                         bool maximum_width)
        -: 1790:{
    #####: 1791:    PyObject* object = NULL;
    #####: 1792:    PyObject* items = NULL;
        -: 1793:
    #####: 1794:    Py_ssize_t nparameters;
    #####: 1795:    char* params = NULL;
    #####: 1796:    Py_ssize_t nparams = 0;
        -: 1797:
    #####: 1798:    Py_ssize_t ix;
        -: 1799:
    #####: 1800:    if (ParamStyle_named == paramstyle)
branch  0 never executed
branch  1 never executed
        -: 1801:    {
    #####: 1802:        PyObject* tmp = PyMapping_Items(parameters);
call    0 never executed
    #####: 1803:        if (!tmp)
branch  0 never executed
branch  1 never executed
        -: 1804:        {
        -: 1805:            return NULL;
        -: 1806:        }
    #####: 1807:        items = PySequence_Fast(tmp, NULL);
call    0 never executed
    #####: 1808:        assert(NULL != items);
    #####: 1809:        parameters = items;
    #####: 1810:        Py_DECREF(tmp);
branch  0 never executed
branch  1 never executed
        -: 1811:    }
        -: 1812:
    #####: 1813:    nparameters = PySequence_Fast_GET_SIZE(parameters);
branch  0 never executed
branch  1 never executed
    #####: 1814:    for (ix = 0; ix < nparameters; ++ix)
branch  0 never executed
branch  1 never executed
        -: 1815:    {
    #####: 1816:        char* sqltype = NULL;
    #####: 1817:        char* paramdesc = NULL;
    #####: 1818:        size_t nparamdesc;
        -: 1819:
    #####: 1820:        char* paramname = NULL;
    #####: 1821:        size_t nparamname = 0;
        -: 1822:
    #####: 1823:        struct Parameter* rpcparam = NULL;
    #####: 1824:        PyObject* oparam = NULL;
        -: 1825:
    #####: 1826:        int written;
        -: 1827:
        -: 1828:        /* Determine parameter name for `sp_executesql` SQL statement. */
    #####: 1829:        do
    #####: 1830:        {
    #####: 1831:            if (ParamStyle_named == paramstyle)
branch  0 never executed
branch  1 never executed
        -: 1832:            {
    #####: 1833:                PyObject* item = PySequence_Fast_GET_ITEM(parameters, ix); /* borrowed reference */
branch  0 never executed
branch  1 never executed
    #####: 1834:                PyObject* oname = PyTuple_GET_ITEM(item, 0); /* borrowed reference */
        -: 1835:
    #####: 1836:                paramname = make_paramname(oname, &nparamname);
call    0 never executed
    #####: 1837:                if (!paramname)
branch  0 never executed
branch  1 never executed
        -: 1838:                {
        -: 1839:                    break;
        -: 1840:                }
    #####: 1841:                oparam = PyTuple_GET_ITEM(item, 1); /* borrowed reference */
        -: 1842:            }
        -: 1843:            else
        -: 1844:            {
    #####: 1845:                size_t required = STRLEN("@param" STRINGIFY(UINT64_MAX)) + 1 /* '\0' */;
    #####: 1846:                paramname = tds_mem_malloc(required);
    #####: 1847:                if (!paramname)
branch  0 never executed
branch  1 never executed
        -: 1848:                {
    #####: 1849:                    PyErr_NoMemory();
    #####: 1850:                    break;
call    0 never executed
        -: 1851:                }
    #####: 1852:                nparamname = (size_t)PyOS_snprintf(paramname,
call    0 never executed
        -: 1853:                                                   required,
        -: 1854:                                                   "@param%lu",
        -: 1855:                                                   ix);
    #####: 1856:                oparam = PySequence_Fast_GET_ITEM(parameters, ix); /* borrowed reference */
branch  0 never executed
branch  1 never executed
        -: 1857:            }
        -: 1858:
    #####: 1859:            if (PyErr_Occurred())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1860:            {
        -: 1861:                break;
        -: 1862:            }
        -: 1863:
    #####: 1864:            if (!Parameter_Check(oparam))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1865:            {
    #####: 1866:                rpcparam = Parameter_create(oparam, 0);
call    0 never executed
        -: 1867:            }
        -: 1868:            else
        -: 1869:            {
        -: 1870:                /* `oparam` is a borrowed reference, so increment. */
    #####: 1871:                Py_INCREF(oparam);
branch  0 never executed
branch  1 never executed
        -: 1872:                rpcparam = (struct Parameter*)oparam;
        -: 1873:            }
    #####: 1874:            if (!rpcparam)
branch  0 never executed
branch  1 never executed
        -: 1875:            {
        -: 1876:                assert(PyErr_Occurred());
        -: 1877:                break;
        -: 1878:            }
    #####: 1879:            if (0 != Parameter_bind(rpcparam, dbproc))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1880:            {
        -: 1881:                break;
        -: 1882:            }
        -: 1883:
    #####: 1884:            sqltype = Parameter_sqltype(rpcparam, maximum_width);
call    0 never executed
    #####: 1885:            if (!sqltype)
branch  0 never executed
branch  1 never executed
        -: 1886:            {
    #####: 1887:                PyErr_NoMemory();
    #####: 1888:                break;
call    0 never executed
        -: 1889:            }
        -: 1890:
        -: 1891:            /*
        -: 1892:                Generate the param description for this parameter using the
        -: 1893:                following format:
        -: 1894:
        -: 1895:                    @paramname data_type [ OUTPUT ]
        -: 1896:            */
    #####: 1897:            nparamdesc = ((ix) ? STRLEN(", ") : STRLEN("")) +
branch  0 never executed
branch  1 never executed
        -: 1898:                          nparamname +
    #####: 1899:                          STRLEN(" ") +
    #####: 1900:                          strlen(sqltype) +
        -: 1901:                          STRLEN(" OUTPUT") +
        -: 1902:                          1 /* '\0' */;
    #####: 1903:            paramdesc = tds_mem_malloc(nparamdesc);
    #####: 1904:            if (!paramdesc)
branch  0 never executed
branch  1 never executed
        -: 1905:            {
    #####: 1906:                PyErr_NoMemory();
    #####: 1907:                break;
call    0 never executed
        -: 1908:            }
    #####: 1909:            written = PyOS_snprintf(paramdesc,
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 1910:                                    nparamdesc,
        -: 1911:                                    "%s%s %s%s",
        -: 1912:                                    (ix) ? ", " : "",
        -: 1913:                                    paramname,
        -: 1914:                                    sqltype,
    #####: 1915:                                    (Parameter_output(rpcparam)) ? " OUTPUT" : "");
call    0 never executed
    #####: 1916:            assert((size_t)written < nparamdesc);
    #####: 1917:            params = strappend(params, (size_t)nparams, paramdesc, (size_t)written);
call    0 never executed
    #####: 1918:            if (!params)
branch  0 never executed
branch  1 never executed
        -: 1919:            {
    #####: 1920:                PyErr_NoMemory();
    #####: 1921:                break;
call    0 never executed
        -: 1922:            }
    #####: 1923:            nparams += written;
        -: 1924:        } while (0);
    #####: 1925:        tds_mem_free(sqltype);
    #####: 1926:        tds_mem_free(paramdesc);
    #####: 1927:        tds_mem_free(paramname);
        -: 1928:
    #####: 1929:        Py_XDECREF((PyObject*)rpcparam);
call    0 never executed
        -: 1930:
    #####: 1931:        if (PyErr_Occurred())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1932:        {
        -: 1933:            break;
        -: 1934:        }
        -: 1935:    }
    #####: 1936:    if (!PyErr_Occurred())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1937:    {
    #####: 1938:        object = PyUnicode_DecodeUTF8(params, nparams, "strict");
call    0 never executed
        -: 1939:    }
    #####: 1940:    tds_mem_free(params);
        -: 1941:
    #####: 1942:    Py_XDECREF(items);
        -: 1943:
    #####: 1944:    return object;
call    0 never executed
        -: 1945:}
        -: 1946:
        -: 1947:
        -: 1948:/*
        -: 1949:    Construct and execute a SQL statement. This will execute the SQL using the
        -: 1950:    `sp_executesql` stored procedure, to support optimal batching support.
        -: 1951:
        -: 1952:    @note This does not check the cursor state (i.e. open, connected).
        -: 1953:
        -: 1954:    @param cursor [in] The Cursor.
        -: 1955:    @param sqlfmt [in] A SQL format string, using the numeric DB API 2 for
        -: 1956:       parameter markers.
        -: 1957:    @param sequence [in] An optional sequence of parameters to the SQL
        -: 1958:       statement.
        -: 1959:    @param minimize_types [in] Convert Python types to the minimum required size
        -: 1960:       in SQL. This only applies to variable width types, such as (N)(VAR)CHAR.
        -: 1961:
        -: 1962:    @return 0 on success, -1 on error.
        -: 1963:*/
function Cursor_execute_internal called 0 returned 0% blocks executed 0%
    #####: 1964:static int Cursor_execute_internal(struct Cursor* cursor, const char* sqlfmt, PyObject* sequence, bool minimize_types)
        -: 1965:{
    #####: 1966:    PyObject* isequence = PyObject_GetIter(sequence);
call    0 never executed
    #####: 1967:    if (isequence)
branch  0 never executed
branch  1 never executed
        -: 1968:    {
    #####: 1969:        size_t ix = 0;
        -: 1970:
    #####: 1971:        PyObject* parameters = NULL; /* current parameters, if any */
    #####: 1972:        PyObject* callprocargs = NULL;
    #####: 1973:        Py_ssize_t nparameters = 0;
        -: 1974:
    #####: 1975:        bool namedparams = (ParamStyle_named == cursor->paramstyle);
        -: 1976:
    #####: 1977:        PyObject* nextparams = PyIter_Next(isequence);
call    0 never executed
    #####: 1978:        do
        -: 1979:        {
    #####: 1980:            if (nextparams)
branch  0 never executed
branch  1 never executed
        -: 1981:            {
    #####: 1982:                Py_XDECREF(parameters);
call    0 never executed
    #####: 1983:                parameters = NULL;
    #####: 1984:                if (!namedparams)
branch  0 never executed
branch  1 never executed
        -: 1985:                {
    #####: 1986:                    static const char s_fmt[] = "invalid parameter sequence item %ld";
        -: 1987:
    #####: 1988:                    char msg[ARRAYSIZE(s_fmt) + ARRAYSIZE(STRINGIFY(UINT64_MAX))];
    #####: 1989:                    (void)sprintf(msg, s_fmt, ix);
    #####: 1990:                    parameters = PySequence_Fast(nextparams, msg);
call    0 never executed
        -: 1991:                }
        -: 1992:                else
        -: 1993:                {
    #####: 1994:                    if (PyMapping_Check(nextparams))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1995:                    {
    #####: 1996:                        Py_INCREF(nextparams);
branch  0 never executed
branch  1 never executed
        -: 1997:                        parameters = nextparams;
        -: 1998:                    }
        -: 1999:                    else
        -: 2000:                    {
    #####: 2001:                        PyErr_Format(PyExc_TypeError, "invalid parameter mapping item %ld", ix);
    #####: 2002:                        assert(NULL == parameters);
        -: 2003:                    }
        -: 2004:                }
        -: 2005:
    #####: 2006:                if (!parameters)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2007:                {
        -: 2008:                    break;
        -: 2009:                }
    #####: 2010:                ix++;
        -: 2011:            }
    #####: 2012:            if (callprocargs)
branch  0 never executed
branch  1 never executed
        -: 2013:            {
    #####: 2014:                Py_ssize_t size = (namedparams) ? PyMapping_Size(parameters) : PySequence_Fast_GET_SIZE(parameters);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2015:                if (nparameters != size)
branch  0 never executed
branch  1 never executed
        -: 2016:                {
    #####: 2017:                    PyErr_Format(PyExc_tds_InterfaceError,
branch  0 never executed
branch  1 never executed
        -: 2018:                                 "unexpected parameter count in %s item %ld",
        -: 2019:                                 (namedparams) ? "mapping" : "sequence",
        -: 2020:                                 ix);
    #####: 2021:                    break;
call    0 never executed
        -: 2022:                }
        -: 2023:            }
        -: 2024:            else
        -: 2025:            {
    #####: 2026:                char* sql;
    #####: 2027:                size_t nsql;
    #####: 2028:                PyObject* value = NULL;
        -: 2029:
        -: 2030:                /*
        -: 2031:                    Create the callproc arguments on the first (and possibly only) iteration.
        -: 2032:                    When passing named parameters, the `@stmt` and `@params` must be first.
        -: 2033:                    Therefore it is necessary to pass the named parameters to `sp_executesql`
        -: 2034:                    as a sequence of key-value pairs.
        -: 2035:                */
    #####: 2036:                if (parameters)
branch  0 never executed
branch  1 never executed
        -: 2037:                {
    #####: 2038:                    nparameters = (namedparams) ? PyMapping_Length(parameters) : PySequence_Fast_GET_SIZE(parameters);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 2039:                }
        -: 2040:                else
        -: 2041:                {
        -: 2042:                    nparameters = 0;
        -: 2043:                }
    #####: 2044:                callprocargs = PyTuple_New(1 + ((nparameters) ? 1 : 0) + nparameters);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2045:                if (!callprocargs)
branch  0 never executed
branch  1 never executed
        -: 2046:                {
        -: 2047:                    break;
        -: 2048:                }
        -: 2049:
    #####: 2050:                do
    #####: 2051:                {
    #####: 2052:                    PyObject* pair = NULL;
    #####: 2053:                    sql = build_executesql_stmt(Connection_DBPROCESS(cursor->connection),
call    0 never executed
        -: 2054:                                                sqlfmt,
        -: 2055:                                                cursor->paramstyle,
        -: 2056:                                                parameters,
        -: 2057:                                                nparameters,
        -: 2058:                                                !minimize_types,
    #####: 2059:                                                &nsql);
call    0 never executed
    #####: 2060:                    if (!sql)
branch  0 never executed
branch  1 never executed
        -: 2061:                    {
        -: 2062:                        break;
        -: 2063:                    }
        -: 2064:
    #####: 2065:                    value = PyUnicode_DecodeUTF8(sql, (Py_ssize_t)nsql, "strict");
call    0 never executed
    #####: 2066:                    if (!value)
branch  0 never executed
branch  1 never executed
        -: 2067:                    {
        -: 2068:                        break;
        -: 2069:                    }
        -: 2070:
    #####: 2071:                    if (namedparams)
branch  0 never executed
branch  1 never executed
        -: 2072:                    {
    #####: 2073:                        pair = Py_BuildValue("(zO)", "@stmt", value);
call    0 never executed
    #####: 2074:                        if (!pair)
branch  0 never executed
branch  1 never executed
        -: 2075:                        {
        -: 2076:                            break;
        -: 2077:                        }
    #####: 2078:                        PyTuple_SET_ITEM(callprocargs, 0, pair);
        -: 2079:                    }
        -: 2080:                    else
        -: 2081:                    {
    #####: 2082:                        PyTuple_SET_ITEM(callprocargs, 0, value);
    #####: 2083:                        value = NULL; /* reference stolen by PyTuple_SET_ITEM */
        -: 2084:                    }
        -: 2085:                }
        -: 2086:                while (0);
        -: 2087:
    #####: 2088:                tds_mem_free(sql);
    #####: 2089:                sql = NULL;
        -: 2090:
    #####: 2091:                Py_XDECREF(value);
call    0 never executed
    #####: 2092:                value = NULL;
        -: 2093:
    #####: 2094:                if (PyErr_Occurred())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2095:                {
        -: 2096:                    break;
        -: 2097:                }
        -: 2098:
        -: 2099:                /*
        -: 2100:                    Construct the @params parameter based on the first parameters tuple
        -: 2101:                    in the sequence.
        -: 2102:                 */
    #####: 2103:                if (nparameters)
branch  0 never executed
branch  1 never executed
        -: 2104:                {
    #####: 2105:                    do
    #####: 2106:                    {
    #####: 2107:                        PyObject* pair = NULL;
    #####: 2108:                        value = build_executesql_params(Connection_DBPROCESS(cursor->connection),
call    0 never executed
call    1 never executed
        -: 2109:                                                        cursor->paramstyle,
        -: 2110:                                                        parameters,
        -: 2111:                                                        !minimize_types);
    #####: 2112:                        if (!value)
branch  0 never executed
branch  1 never executed
        -: 2113:                        {
        -: 2114:                            break;
        -: 2115:                        }
        -: 2116:
    #####: 2117:                        if (namedparams)
branch  0 never executed
branch  1 never executed
        -: 2118:                        {
    #####: 2119:                            pair = Py_BuildValue("(zO)", "@params", value);
call    0 never executed
    #####: 2120:                            if (!pair)
branch  0 never executed
branch  1 never executed
        -: 2121:                            {
        -: 2122:                                break;
        -: 2123:                            }
    #####: 2124:                            PyTuple_SET_ITEM(callprocargs, 1, pair);
        -: 2125:                        }
        -: 2126:                        else
        -: 2127:                        {
    #####: 2128:                            PyTuple_SET_ITEM(callprocargs, 1, value);
    #####: 2129:                            value = NULL; /* reference stolen by PyTuple_SET_ITEM */
        -: 2130:                        }
        -: 2131:                    }
        -: 2132:                    while (0);
        -: 2133:
    #####: 2134:                    Py_XDECREF(value);
call    0 never executed
    #####: 2135:                    value = NULL;
        -: 2136:
    #####: 2137:                    if (PyErr_Occurred())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2138:                    {
        -: 2139:                        break;
        -: 2140:                    }
        -: 2141:                }
        -: 2142:            }
        -: 2143:
    #####: 2144:            if (parameters)
branch  0 never executed
branch  1 never executed
        -: 2145:            {
    #####: 2146:                if (!namedparams)
branch  0 never executed
branch  1 never executed
        -: 2147:                {
        -: 2148:                    Py_ssize_t ixparam;
    #####: 2149:                    for (ixparam = 0; ixparam < nparameters; ++ixparam)
branch  0 never executed
branch  1 never executed
        -: 2150:                    {
    #####: 2151:                        PyObject* param = PySequence_Fast_GET_ITEM(parameters, ixparam);
branch  0 never executed
branch  1 never executed
    #####: 2152:                        Py_INCREF(param); /* param reference stolen by PyTuple_SetItem */
branch  0 never executed
branch  1 never executed
        -: 2153:
        -: 2154:                        /* Use PyTuple_SetItem to properly overwrite existing values. */
    #####: 2155:                        if (0 != PyTuple_SetItem(callprocargs, ixparam + 2 /* @stmt, @params */, param))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2156:                        {
    #####: 2157:                            Py_DECREF(param);
branch  0 never executed
branch  1 never executed
        -: 2158:                            break;
        -: 2159:                        }
        -: 2160:                    }
        -: 2161:                }
        -: 2162:                else
        -: 2163:                {
        -: 2164:                    /*
        -: 2165:                        Iterate over the parameters, prepending a '@' to the names,
        -: 2166:                        and adding to the callproc arguments.
        -: 2167:                    */
    #####: 2168:                    PyObject* items = NULL;
    #####: 2169:                    PyObject* seq = NULL;
    #####: 2170:                    do
    #####: 2171:                    {
    #####: 2172:                        Py_ssize_t ixparam;
    #####: 2173:                        items = PyMapping_Items(parameters);
call    0 never executed
    #####: 2174:                        if (!items)
branch  0 never executed
branch  1 never executed
        -: 2175:                        {
        -: 2176:                            break;
        -: 2177:                        }
    #####: 2178:                        seq = PySequence_Tuple(items);
    #####: 2179:                        if (!items)
call    0 never executed
        -: 2180:                        {
        -: 2181:                            break;
        -: 2182:                        }
        -: 2183:
        -: 2184:                        assert(PySequence_Fast_GET_SIZE(seq) == nparameters);
    #####: 2185:                        for (ixparam = 0; ixparam < nparameters; ++ixparam)
branch  0 never executed
branch  1 never executed
        -: 2186:                        {
    #####: 2187:                            PyObject* item = PySequence_Fast_GET_ITEM(seq, ixparam); /* borrowed reference */
branch  0 never executed
branch  1 never executed
    #####: 2188:                            PyObject* key = PyTuple_GET_ITEM(item, 0); /* borrowed reference */
    #####: 2189:                            PyObject* value = PyTuple_GET_ITEM(item, 1); /* borrowed reference */
        -: 2190:
    #####: 2191:                            char* paramname = NULL;
    #####: 2192:                            PyObject* args = NULL;
    #####: 2193:                            do
    #####: 2194:                            {
    #####: 2195:                                paramname = make_paramname(key, NULL);
call    0 never executed
    #####: 2196:                                if (!paramname)
branch  0 never executed
branch  1 never executed
        -: 2197:                                {
        -: 2198:                                    break;
        -: 2199:                                }
        -: 2200:
    #####: 2201:                                args = Py_BuildValue("(zO)", paramname, value);
call    0 never executed
    #####: 2202:                                if (!args)
branch  0 never executed
branch  1 never executed
        -: 2203:                                {
        -: 2204:                                    break;
        -: 2205:                                }
        -: 2206:
        -: 2207:                                /* Use PyTuple_SetItem to properly overwrite existing values. */
    #####: 2208:                                if (0 != PyTuple_SetItem(callprocargs, ixparam + 2 /* @stmt, @params */, args))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2209:                                {
        -: 2210:                                    break;
        -: 2211:                                }
        -: 2212:
        -: 2213:                                /* args reference stolen by PyTuple_SetItem */
    #####: 2214:                                args = NULL;
        -: 2215:                            }
        -: 2216:                            while (0);
        -: 2217:
    #####: 2218:                            tds_mem_free(paramname);
    #####: 2219:                            Py_XDECREF(args);
call    0 never executed
    #####: 2220:                            args = NULL;
        -: 2221:
    #####: 2222:                            if (PyErr_Occurred())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2223:                            {
        -: 2224:                                break;
        -: 2225:                            }
        -: 2226:                        }
        -: 2227:                    }
        -: 2228:                    while (0);
        -: 2229:
    #####: 2230:                    Py_XDECREF(items);
call    0 never executed
    #####: 2231:                    Py_XDECREF(seq);
call    0 never executed
        -: 2232:                }
        -: 2233:            }
    #####: 2234:            if (!PyErr_Occurred())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2235:            {
    #####: 2236:                PyObject* output = Cursor_callproc_internal(cursor,
call    0 never executed
        -: 2237:                                                            "sp_executesql",
        -: 2238:                                                            callprocargs,
        -: 2239:                                                            namedparams);
    #####: 2240:                Py_XDECREF(output);
call    0 never executed
        -: 2241:            }
    #####: 2242:            if (PyErr_Occurred())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2243:            {
        -: 2244:                break;
        -: 2245:            }
    #####: 2246:            Py_XDECREF(nextparams);
call    0 never executed
        -: 2247:        }
    #####: 2248:        while (NULL != (nextparams = PyIter_Next(isequence)));
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2249:
    #####: 2250:        Py_XDECREF(nextparams);
call    0 never executed
    #####: 2251:        Py_XDECREF(parameters);
call    0 never executed
    #####: 2252:        Py_XDECREF(callprocargs);
call    0 never executed
        -: 2253:
    #####: 2254:        Py_DECREF(isequence);
branch  0 never executed
branch  1 never executed
        -: 2255:    }
        -: 2256:
    #####: 2257:    return (PyErr_Occurred()) ? -1 : 0;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2258:}
        -: 2259:
        -: 2260:#else /* if defined(CTDS_USE_SP_EXECUTESQL) */
        -: 2261:
        -: 2262:static int Cursor_execute_internal(struct Cursor* cursor, const char* sqlfmt, PyObject* sequence, bool minimize_types)
        -: 2263:{
        -: 2264:    PyObject* isequence = PyObject_GetIter(sequence);
        -: 2265:    if (isequence)
        -: 2266:    {
        -: 2267:        size_t paramN = 0;
        -: 2268:
        -: 2269:        PyObject* parameters = NULL; /* current parameters, if any */
        -: 2270:        Py_ssize_t nparameters = 0;
        -: 2271:
        -: 2272:        PyObject* nextparams = PyIter_Next(isequence);
        -: 2273:        do
        -: 2274:        {
        -: 2275:            bool error;
        -: 2276:
        -: 2277:            char* sql;
        -: 2278:            size_t nsql;
        -: 2279:
        -: 2280:            Py_ssize_t currnparameters;
        -: 2281:
        -: 2282:            if (nextparams)
        -: 2283:            {
        -: 2284:                assert(NULL == parameters);
        -: 2285:                if (ParamStyle_numeric == cursor->paramstyle)
        -: 2286:                {
        -: 2287:                    static const char s_fmt[] = "invalid parameter sequence item %ld";
        -: 2288:
        -: 2289:                    char msg[ARRAYSIZE(s_fmt) + ARRAYSIZE(STRINGIFY(UINT64_MAX))];
        -: 2290:                    (void)sprintf(msg, s_fmt, paramN);
        -: 2291:
        -: 2292:                    parameters = PySequence_Fast(nextparams, msg);
        -: 2293:                }
        -: 2294:                else
        -: 2295:                {
        -: 2296:                    if (PyMapping_Check(nextparams))
        -: 2297:                    {
        -: 2298:                        Py_INCREF(nextparams);
        -: 2299:                        parameters = nextparams;
        -: 2300:                    }
        -: 2301:                    else
        -: 2302:                    {
        -: 2303:                        PyErr_Format(PyExc_TypeError, "invalid parameter mapping item %ld", paramN);
        -: 2304:                        assert(NULL == parameters);
        -: 2305:                    }
        -: 2306:                }
        -: 2307:
        -: 2308:                if (!parameters)
        -: 2309:                {
        -: 2310:                    break;
        -: 2311:                }
        -: 2312:                /* Set the expected parameter count based on the first sequence. */
        -: 2313:                if (0 == paramN)
        -: 2314:                {
        -: 2315:                    nparameters = (ParamStyle_numeric == cursor->paramstyle) ?
        -: 2316:                        PySequence_Fast_GET_SIZE(parameters) : PyMapping_Size(parameters);
        -: 2317:                }
        -: 2318:                paramN++;
        -: 2319:            }
        -: 2320:
        -: 2321:            if (parameters)
        -: 2322:            {
        -: 2323:                currnparameters = (ParamStyle_numeric == cursor->paramstyle) ?
        -: 2324:                    PySequence_Fast_GET_SIZE(parameters) : PyMapping_Size(parameters);
        -: 2325:            }
        -: 2326:            else
        -: 2327:            {
        -: 2328:                currnparameters = 0;
        -: 2329:            }
        -: 2330:            if (nparameters != currnparameters)
        -: 2331:            {
        -: 2332:                PyErr_Format(PyExc_tds_InterfaceError,
        -: 2333:                             "unexpected parameter count in %s item %ld",
        -: 2334:                             (ParamStyle_numeric == cursor->paramstyle) ? "sequence" : "mapping",
        -: 2335:                             paramN);
        -: 2336:                break;
        -: 2337:            }
        -: 2338:
        -: 2339:            sql = build_executesql_stmt(Connection_DBPROCESS(cursor->connection),
        -: 2340:                                        sqlfmt,
        -: 2341:                                        cursor->paramstyle,
        -: 2342:                                        parameters,
        -: 2343:                                        nparameters,
        -: 2344:                                        !minimize_types,
        -: 2345:                                        &nsql);
        -: 2346:            Py_XDECREF(parameters);
        -: 2347:            parameters = NULL;
        -: 2348:            if (!sql)
        -: 2349:            {
        -: 2350:                break;
        -: 2351:            }
        -: 2352:
        -: 2353:            error = (0 != Cursor_execute_sql(cursor, sql));
        -: 2354:            tds_mem_free(sql);
        -: 2355:
        -: 2356:            if (error)
        -: 2357:            {
        -: 2358:                break;
        -: 2359:            }
        -: 2360:        }
        -: 2361:        while (NULL != (nextparams = PyIter_Next(isequence)));
        -: 2362:
        -: 2363:        Py_XDECREF(nextparams);
        -: 2364:        Py_XDECREF(parameters);
        -: 2365:
        -: 2366:        Py_DECREF(isequence);
        -: 2367:    }
        -: 2368:
        -: 2369:    return (PyErr_Occurred()) ? -1 : 0;
        -: 2370:}
        -: 2371:
        -: 2372:#endif /* else if defined(CTDS_USE_SP_EXECUTESQL) */
        -: 2373:
        -: 2374:
        -: 2375:/* https://www.python.org/dev/peps/pep-0249/#execute */
        -: 2376:static const char s_Cursor_execute_doc[] =
        -: 2377:    "execute(sql, parameters=None)\n"
        -: 2378:    "\n"
        -: 2379:    "Prepare and execute a database operation.\n"
        -: 2380:    "Parameters may be provided as sequence and will be bound to variables\n"
        -: 2381:    "specified in the SQL statement. Parameter notation is specified by\n"
        -: 2382:    ":py:const:`k_ctds.paramstyle`.\n"
        -: 2383:    "\n"
        -: 2384:    ":pep:`0249#execute`\n"
        -: 2385:    "\n"
        -: 2386:    ":param str sql: The SQL statement to execute.\n"
        -: 2387:
        -: 2388:    ":param tuple parameters: Optional variables to bind.\n";
        -: 2389:
function Cursor_execute called 0 returned 0% blocks executed 0%
    #####: 2390:static PyObject* Cursor_execute(PyObject* self, PyObject* args)
        -: 2391:{
    #####: 2392:    char* sqlfmt;
    #####: 2393:    PyObject* parameters = NULL;
    #####: 2394:    PyObject* sequence;
    #####: 2395:    int error;
        -: 2396:
    #####: 2397:    struct Cursor* cursor = (struct Cursor*)self;
    #####: 2398:    Cursor_verify_open(cursor);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2399:    Cursor_verify_connection_open(cursor);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 2400:
    #####: 2401:    if (!PyArg_ParseTuple(args, "s|O", &sqlfmt, &parameters))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2402:    {
        -: 2403:        return NULL;
        -: 2404:    }
        -: 2405:
    #####: 2406:    if (parameters)
branch  0 never executed
branch  1 never executed
        -: 2407:    {
    #####: 2408:        if (((ParamStyle_numeric == cursor->paramstyle) && !PySequence_Check(parameters)) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2409:            ((ParamStyle_named == cursor->paramstyle) && !PyMapping_Check(parameters)))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 2410:        {
    #####: 2411:            PyErr_SetObject(PyExc_TypeError, parameters);
    #####: 2412:            return NULL;
call    0 never executed
        -: 2413:        }
        -: 2414:
    #####: 2415:        sequence = PyTuple_New(PyObject_Length(parameters) ? 1 : 0);
call    0 never executed
call    1 never executed
    #####: 2416:        if (!sequence)
branch  0 never executed
branch  1 never executed
        -: 2417:        {
        -: 2418:            return NULL;
        -: 2419:        }
        -: 2420:
    #####: 2421:        if (PyObject_Length(parameters))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2422:        {
    #####: 2423:            Py_INCREF(parameters);
branch  0 never executed
branch  1 never executed
    #####: 2424:            PyTuple_SET_ITEM(sequence, 0, parameters); /* parameters reference stolen by PyTuple_SET_ITEM */
        -: 2425:        }
    #####: 2426:        error = Cursor_execute_internal(cursor, sqlfmt, sequence, true /* minimize_types */);
call    0 never executed
    #####: 2427:        Py_DECREF(sequence);
branch  0 never executed
branch  1 never executed
        -: 2428:    }
        -: 2429:    else
        -: 2430:    {
    #####: 2431:        error = Cursor_execute_sql(cursor, sqlfmt);
call    0 never executed
        -: 2432:    }
    #####: 2433:    if (0 != error)
branch  0 never executed
branch  1 never executed
        -: 2434:    {
    #####: 2435:        return NULL;
        -: 2436:    }
        -: 2437:    Py_RETURN_NONE;
        -: 2438:}
        -: 2439:
        -: 2440:/* https://www.python.org/dev/peps/pep-0249/#executemany */
        -: 2441:static const char s_Cursor_executemany_doc[] =
        -: 2442:    "executemany(sql, seq_of_parameters)\n"
        -: 2443:    "\n"
        -: 2444:    "Prepare a database operation (query or command) and then execute it\n"
        -: 2445:    "against all parameter sequences or mappings found in the sequence\n"
        -: 2446:    "`seq_of_parameters`.\n"
        -: 2447:    "\n"
        -: 2448:    ":pep:`0249#executemany`\n"
        -: 2449:    "\n"
        -: 2450:    ":param str sql: The SQL statement to execute.\n"
        -: 2451:
        -: 2452:    ":param seq_of_parameters: An iterable of parameter sequences to bind.\n"
        -: 2453:    ":type seq_of_parameters: :ref:`typeiter <python:typeiter>`\n";
        -: 2454:
function Cursor_executemany called 0 returned 0% blocks executed 0%
    #####: 2455:PyObject* Cursor_executemany(PyObject* self, PyObject* args)
        -: 2456:{
    #####: 2457:    char* sqlfmt;
    #####: 2458:    PyObject* iterable;
        -: 2459:
    #####: 2460:    struct Cursor* cursor = (struct Cursor*)self;
    #####: 2461:    Cursor_verify_open(cursor);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2462:    Cursor_verify_connection_open(cursor);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 2463:
    #####: 2464:    if (!PyArg_ParseTuple(args, "sO", &sqlfmt, &iterable))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2465:    {
        -: 2466:        return NULL;
        -: 2467:    }
        -: 2468:
        -: 2469:    /*
        -: 2470:        Explicitly do not minimize SQL type widths in executemany to avoid truncation issues
        -: 2471:        when using sp_executesql and inferring the SQL type from the first parameter sequence.
        -: 2472:        If the first sequence has types that map to variable length SQL types, the minimal type
        -: 2473:        size may not be large enough for values in later sequences.
        -: 2474:    */
    #####: 2475:    if (Cursor_execute_internal(cursor, sqlfmt, iterable, false /* minimize_types */))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2476:    {
    #####: 2477:        return NULL;
        -: 2478:    }
        -: 2479:    Py_RETURN_NONE;
        -: 2480:}
        -: 2481:
        -: 2482:struct ColumnBuffer
        -: 2483:{
        -: 2484:    /* The size of this column, in bytes. */
        -: 2485:    size_t size;
        -: 2486:
        -: 2487:    /*
        -: 2488:        The TDS type of this column. This is necessary for COMPUTE columns
        -: 2489:        which may have a different type than the regular column.
        -: 2490:    */
        -: 2491:    enum TdsType tdstype;
        -: 2492:
        -: 2493:    /* The column data. This member must always be last. */
        -: 2494:    union {
        -: 2495:        /* Allocated separately on heap. */
        -: 2496:        void* variable;
        -: 2497:
        -: 2498:        /* Allocated as part of this structure. */
        -: 2499:        uint8_t* fixed;
        -: 2500:    } data;
        -: 2501:};
        -: 2502:
        -: 2503:/*
        -: 2504:    Check whether a database column is variable length or not.
        -: 2505:
        -: 2506:    @param _dbcol [in] A DBCOL* describing the column.
        -: 2507:*/
        -: 2508:#define Column_IsVariableLength(_dbcol) \
        -: 2509:    !!(_dbcol)->VarLength
        -: 2510:
        -: 2511:/*
        -: 2512:    Determine the column buffer size required for a database column.
        -: 2513:
        -: 2514:    @param _dbcol [in] A DBCOL* describing the column.
        -: 2515:*/
        -: 2516:#define ColumnBuffer_size(_dbcol) \
        -: 2517:    ((Column_IsVariableLength(_dbcol)) ? \
        -: 2518:        sizeof(struct ColumnBuffer) : ((size_t)(_dbcol)->MaxLength + offsetof(struct ColumnBuffer, data)))
        -: 2519:
        -: 2520:
        -: 2521:struct RowBuffer
        -: 2522:{
        -: 2523:    /* The next row buffer in the resultset. */
        -: 2524:    struct RowBuffer* next;
        -: 2525:
        -: 2526:    /*
        -: 2527:        A dynamically-sized block of memory large enough for all the row's
        -: 2528:        columns. Because columns themselves are dynamically sized, indexing
        -: 2529:        into this array is non-trivial.
        -: 2530:
        -: 2531:        Iterating column buffers requires use of ColumnBuffer_size() to
        -: 2532:        determine the actual size of the ColumnBuffer.
        -: 2533:    */
        -: 2534:
        -: 2535:/* Ignore "ISO C90 does not support flexible array members". */
        -: 2536:#if defined(__GNUC__) && (__GNUC__ > 4)
        -: 2537:#  pragma GCC diagnostic push
        -: 2538:#  pragma GCC diagnostic ignored "-Wpedantic"
        -: 2539:#endif /* if defined(__GNUC__) && (__GNUC__ > 4) */
        -: 2540:#if defined (_MSC_VER)
        -: 2541:#  pragma warning(disable: 4200)
        -: 2542:#endif /* if defined (_MSC_VER) */
        -: 2543:
        -: 2544:    struct ColumnBuffer columns[];
        -: 2545:
        -: 2546:#if defined (_MSC_VER)
        -: 2547:#  pragma warning(default: 4200)
        -: 2548:#endif /* if defined (_MSC_VER) */
        -: 2549:#if defined(__GNUC__) && (__GNUC__ > 4)
        -: 2550:#  pragma GCC diagnostic pop
        -: 2551:#endif /* if defined(__GNUC__) && (__GNUC__ > 4) */
        -: 2552:};
        -: 2553:
        -: 2554:/*
        -: 2555:    Determine the row buffer size for the current resultset.
        -: 2556:
        -: 2557:    @param description [in] A description of the result set.
        -: 2558:
        -: 2559:    @return The size, in bytes, for a RowBuffer describing
        -: 2560:        the current resultset.
        -: 2561:*/
    #####: 2562:static size_t ResultSetDescription_RowBuffer_size(const struct ResultSetDescription* description)
        -: 2563:{
    #####: 2564:    if (description)
        -: 2565:    {
        -: 2566:        size_t size = 0;
        -: 2567:        size_t ix;
    #####: 2568:        for (ix = 0; ix < description->ncolumns; ++ix)
branch  0 never executed
branch  1 never executed
        -: 2569:        {
    #####: 2570:            size += ColumnBuffer_size(&description->columns[ix].dbcol);
branch  0 never executed
branch  1 never executed
        -: 2571:        }
        -: 2572:
    #####: 2573:        return offsetof(struct RowBuffer, columns) + size;
        -: 2574:    }
        -: 2575:    else
        -: 2576:    {
        -: 2577:        return 0;
        -: 2578:    }
        -: 2579:}
        -: 2580:
        -: 2581:/*
        -: 2582:    Release all memory referenced by a RowBuffer.
        -: 2583:
        -: 2584:    @param description [in] A description of the result set for the `rowbuffer`.
        -: 2585:    @param rowbuffer [in] The first row in the resultset.
        -: 2586:*/
function ResultSetDescription_RowBuffer_free called 0 returned 0% blocks executed 0%
    #####: 2587:static void ResultSetDescription_RowBuffer_free(const struct ResultSetDescription* description,
        -: 2588:                                                struct RowBuffer* rowbuffer)
        -: 2589:{
    #####: 2590:    while (rowbuffer)
branch  0 never executed
branch  1 never executed
        -: 2591:    {
    #####: 2592:        struct RowBuffer* next = rowbuffer->next;
        -: 2593:
    #####: 2594:        struct ColumnBuffer* column = rowbuffer->columns;
    #####: 2595:        size_t ix;
    #####: 2596:        for (ix = 0; ix < description->ncolumns; ++ix)
branch  0 never executed
branch  1 never executed
        -: 2597:        {
    #####: 2598:            const DBCOL* dbcol = &description->columns[ix].dbcol;
    #####: 2599:            if (Column_IsVariableLength(dbcol))
branch  0 never executed
branch  1 never executed
        -: 2600:            {
    #####: 2601:                tds_mem_free(column->data.variable);
    #####: 2602:                column->data.variable = 0;
        -: 2603:            }
    #####: 2604:            column = (struct ColumnBuffer*)((char*)column + ColumnBuffer_size(dbcol));
branch  0 never executed
branch  1 never executed
        -: 2605:        }
    #####: 2606:        tds_mem_free(rowbuffer);
    #####: 2607:        rowbuffer = next;
        -: 2608:    }
    #####: 2609:}
        -: 2610:
        -: 2611:struct Row {
        -: 2612:    PyObject_VAR_HEAD
        -: 2613:
        -: 2614:    struct ResultSetDescription* description;
        -: 2615:
        -: 2616:    PyObject* values[1]; /* space for row data values is added by tp_alloc() */
        -: 2617:};
        -: 2618:
function Row_dealloc called 0 returned 0% blocks executed 0%
    #####: 2619:static void Row_dealloc(PyObject* self)
        -: 2620:{
    #####: 2621:    struct Row* row = (struct Row*)self;
    #####: 2622:    size_t ix;
    #####: 2623:    for (ix = 0; ix < row->description->ncolumns; ++ix)
branch  0 never executed
branch  1 never executed
        -: 2624:    {
    #####: 2625:        Py_XDECREF(row->values[ix]);
call    0 never executed
        -: 2626:    }
    #####: 2627:    ResultSetDescription_decrement(row->description);
call    0 never executed
    #####: 2628:    PyObject_Del(self);
call    0 never executed
    #####: 2629:}
        -: 2630:
        -: 2631:PyTypeObject RowType; /* forward decl. */
function Row_create called 0 returned 0% blocks executed 0%
    #####: 2632:static struct Row* Row_create(struct ResultSetDescription* description,
        -: 2633:                              const struct RowBuffer* rowbuffer)
        -: 2634:{
    #####: 2635:    struct Row* row = PyObject_NewVar(struct Row, &RowType, (Py_ssize_t)description->ncolumns);
call    0 never executed
    #####: 2636:    if (row)
branch  0 never executed
branch  1 never executed
        -: 2637:    {
        -: 2638:        /* The offset to the next column buffer in the row. */
    #####: 2639:        size_t offset = 0;
    #####: 2640:        size_t ixcol;
        -: 2641:
    #####: 2642:        memset(row->values, 0, description->ncolumns * sizeof(*row->values));
    #####: 2643:        row->description = description;
    #####: 2644:        ResultSetDescription_increment(description);
        -: 2645:
    #####: 2646:        for (ixcol = 0; ixcol < description->ncolumns; ++ixcol)
branch  0 never executed
branch  1 never executed
        -: 2647:        {
    #####: 2648:            const struct Column* column = &description->columns[ixcol];
        -: 2649:
    #####: 2650:            if (column->topython)
branch  0 never executed
branch  1 never executed
        -: 2651:            {
    #####: 2652:                const struct ColumnBuffer* colbuffer = (const struct ColumnBuffer*)(((const char*)rowbuffer->columns) + offset);
        -: 2653:
    #####: 2654:                const void* data = (Column_IsVariableLength(&column->dbcol)) ?
    #####: 2655:                    colbuffer->data.variable : &colbuffer->data.fixed;
branch  0 never executed
branch  1 never executed
        -: 2656:
    #####: 2657:                PyObject* object = NULL;
        -: 2658:
        -: 2659:                /*
        -: 2660:                    Used the cached column converter if the type is expected.
        -: 2661:                    The type may differ for COMPUTE columns, in which case the
        -: 2662:                    converter won't be cached.
        -: 2663:                */
    #####: 2664:                if ((enum TdsType)column->dbcol.Type == colbuffer->tdstype)
branch  0 never executed
branch  1 never executed
        -: 2665:                {
    #####: 2666:                    object = column->topython(colbuffer->tdstype,
        -: 2667:                                              data,
    #####: 2668:                                              colbuffer->size);
call    0 never executed
        -: 2669:                }
        -: 2670:                else
        -: 2671:                {
    #####: 2672:                    sql_topython topython = sql_topython_lookup(colbuffer->tdstype);
call    0 never executed
    #####: 2673:                    assert(topython);
    #####: 2674:                    object = topython(colbuffer->tdstype,
        -: 2675:                                      data,
    #####: 2676:                                      colbuffer->size);
call    0 never executed
        -: 2677:                }
    #####: 2678:                if (!object)
branch  0 never executed
branch  1 never executed
        -: 2679:                {
        -: 2680:                    break;
        -: 2681:                }
        -: 2682:
    #####: 2683:                row->values[ixcol] = object; /* object reference stolen */
        -: 2684:            }
        -: 2685:            else
        -: 2686:            {
    #####: 2687:                PyErr_Format(PyExc_tds_NotSupportedError,
        -: 2688:                             "unsupported type %d for column \"%s\"",
    #####: 2689:                             column->dbcol.Type,
    #####: 2690:                             column->dbcol.ActualName);
    #####: 2691:                break;
call    0 never executed
        -: 2692:            }
    #####: 2693:            offset += ColumnBuffer_size(&column->dbcol);
branch  0 never executed
branch  1 never executed
        -: 2694:        }
    #####: 2695:        if (PyErr_Occurred())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2696:        {
    #####: 2697:            Py_DECREF(row);
branch  0 never executed
branch  1 never executed
        -: 2698:            row = NULL;
        -: 2699:        }
        -: 2700:    }
        -: 2701:    else
        -: 2702:    {
    #####: 2703:        PyErr_NoMemory();
call    0 never executed
        -: 2704:    }
    #####: 2705:    return row;
        -: 2706:}
        -: 2707:
function Row_lookup_column called 0 returned 0% blocks executed 0%
    #####: 2708:static PyObject* Row_lookup_column(PyObject* self, PyObject* item, PyObject* error)
        -: 2709:{
    #####: 2710:    struct Row* row = (struct Row*)self;
    #####: 2711:    PyObject* value = NULL;
    #####: 2712:    const char* name = NULL;
    #####: 2713:    size_t ix;
        -: 2714:
        -: 2715:#if PY_MAJOR_VERSION < 3
        -: 2716:    PyObject* utf8item = NULL;
        -: 2717:    if (PyUnicode_Check(item))
        -: 2718:    {
        -: 2719:        utf8item = PyUnicode_AsUTF8String(item);
        -: 2720:        if (!utf8item)
        -: 2721:        {
        -: 2722:            return NULL;
        -: 2723:        }
        -: 2724:        name = PyString_AS_STRING(utf8item);
        -: 2725:    }
        -: 2726:    else
        -: 2727:    {
        -: 2728:        if (PyString_Check(item))
        -: 2729:        {
        -: 2730:            name = PyString_AS_STRING(item);
        -: 2731:        }
        -: 2732:    }
        -: 2733:#else /* if PY_MAJOR_VERSION < 3 */
    #####: 2734:    if (PyUnicode_Check(item))
branch  0 never executed
branch  1 never executed
        -: 2735:    {
    #####: 2736:        name = PyUnicode_AsUTF8(item);
call    0 never executed
        -: 2737:    }
        -: 2738:#endif /* else if PY_MAJOR_VERSION < 3 */
        -: 2739:
    #####: 2740:    if (name)
branch  0 never executed
branch  1 never executed
        -: 2741:    {
    #####: 2742:        for (ix = 0; ix < row->description->ncolumns; ++ix)
branch  0 never executed
branch  1 never executed
        -: 2743:        {
    #####: 2744:            if (0 == strcmp(name, row->description->columns[ix].dbcol.ActualName))
branch  0 never executed
branch  1 never executed
        -: 2745:            {
    #####: 2746:                Py_INCREF(row->values[ix]);
branch  0 never executed
branch  1 never executed
        -: 2747:                value = row->values[ix];
        -: 2748:                break;
        -: 2749:            }
        -: 2750:        }
        -: 2751:    }
        -: 2752:
        -: 2753:#if PY_MAJOR_VERSION < 3
        -: 2754:    Py_XDECREF(utf8item);
        -: 2755:#endif /* if PY_MAJOR_VERSION < 3 */
        -: 2756:
    #####: 2757:    if (!value && error != NULL)
branch  0 never executed
branch  1 never executed
        -: 2758:    {
    #####: 2759:        PyErr_SetObject(error, item);
call    0 never executed
        -: 2760:    }
    #####: 2761:    return value;
        -: 2762:}
        -: 2763:
function Row_len called 0 returned 0% blocks executed 0%
    #####: 2764:static Py_ssize_t Row_len(PyObject* self)
        -: 2765:{
    #####: 2766:    struct Row* row = (struct Row*)self;
    #####: 2767:    return (Py_ssize_t)row->description->ncolumns;
        -: 2768:}
        -: 2769:
function Row_item called 0 returned 0% blocks executed 0%
    #####: 2770:static PyObject* Row_item(PyObject* self, Py_ssize_t ix)
        -: 2771:{
    #####: 2772:    struct Row* row = (struct Row*)self;
    #####: 2773:    if (ix < 0 || ix >= (Py_ssize_t)row->description->ncolumns)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2774:    {
    #####: 2775:        PyErr_SetString(PyExc_IndexError, "index is out of range");
    #####: 2776:        return NULL;
call    0 never executed
        -: 2777:    }
    #####: 2778:    Py_INCREF(row->values[ix]);
branch  0 never executed
branch  1 never executed
        -: 2779:    return row->values[ix];
        -: 2780:}
        -: 2781:
function Row_contains called 0 returned 0% blocks executed 0%
    #####: 2782:static int Row_contains(PyObject* self, PyObject* value)
        -: 2783:{
    #####: 2784:    PyObject* item = Row_lookup_column(self, value, NULL);
call    0 never executed
    #####: 2785:    int contains = (NULL != item) ? 1 : 0;
    #####: 2786:    Py_XDECREF(item);
call    0 never executed
    #####: 2787:    return contains;
        -: 2788:}
        -: 2789:
function RowType_init called 0 returned 0% blocks executed 0%
    #####: 2790:PyTypeObject* RowType_init(void)
        -: 2791:{
    #####: 2792:    if (0 != PyType_Ready(&RowType))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2793:    {
    #####: 2794:        return NULL;
        -: 2795:    }
        -: 2796:    return &RowType;
        -: 2797:}
        -: 2798:
        -: 2799:static PySequenceMethods s_Row_as_sequence = {
        -: 2800:    Row_len,      /* sq_length */
        -: 2801:    NULL,         /* sq_concat */
        -: 2802:    NULL,         /* sq_repeat */
        -: 2803:    Row_item,     /* sq_item */
        -: 2804:    NULL,         /* sq_ass_item */
        -: 2805:    NULL,         /* was_sq_slice */
        -: 2806:    NULL,         /* was_sq_ass_slice */
        -: 2807:    Row_contains, /* sq_contains */
        -: 2808:    NULL,         /* sq_inplace_concat */
        -: 2809:    NULL,         /* sq_inplace_repeat */
        -: 2810:};
        -: 2811:
function Row_subscript called 0 returned 0% blocks executed 0%
    #####: 2812:static PyObject* Row_subscript(PyObject* self, PyObject* item)
        -: 2813:{
    #####: 2814:    if (PyUnicode_Check(item)
branch  0 never executed
branch  1 never executed
        -: 2815:#if PY_MAJOR_VERSION < 3
        -: 2816:        || PyString_Check(item)
        -: 2817:#endif /* if PY_MAJOR_VERSION < 3 */
        -: 2818:    )
        -: 2819:    {
    #####: 2820:        return Row_lookup_column(self, item, PyExc_KeyError);
call    0 never executed
        -: 2821:    }
    #####: 2822:    else if (PyLong_Check(item))
branch  0 never executed
branch  1 never executed
        -: 2823:    {
    #####: 2824:        Py_ssize_t ix = PyLong_AsSsize_t(item);
call    0 never executed
    #####: 2825:        if (PyErr_Occurred())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2826:        {
        -: 2827:            return NULL;
        -: 2828:        }
    #####: 2829:        return Row_item(self, ix);
call    0 never executed
        -: 2830:    }
        -: 2831:#if PY_MAJOR_VERSION < 3
        -: 2832:    else if (PyInt_Check(item))
        -: 2833:    {
        -: 2834:        return Row_item(self, PyInt_AsSsize_t(item));
        -: 2835:    }
        -: 2836:#endif /* if PY_MAJOR_VERSION < 3 */
        -: 2837:
    #####: 2838:    PyErr_SetObject(PyExc_KeyError, item);
    #####: 2839:    return NULL;
call    0 never executed
        -: 2840:}
        -: 2841:
        -: 2842:static PyMappingMethods s_Row_as_mapping = {
        -: 2843:    Row_len,       /* mp_length */
        -: 2844:    Row_subscript, /* mp_subscript */
        -: 2845:    NULL,          /* mp_ass_subscript */
        -: 2846:};
        -: 2847:
function Row_getattro called 0 returned 0% blocks executed 0%
    #####: 2848:static PyObject* Row_getattro(PyObject* self, PyObject* attr)
        -: 2849:{
    #####: 2850:    PyObject* value = Row_lookup_column(self, attr, NULL);
call    0 never executed
    #####: 2851:    if (!value && !PyErr_Occurred())
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 2852:    {
    #####: 2853:        value = PyObject_GenericGetAttr(self, attr);
call    0 never executed
        -: 2854:    }
    #####: 2855:    return value;
        -: 2856:}
        -: 2857:
function Row_description_get called 0 returned 0% blocks executed 0%
    #####: 2858:static PyObject* Row_description_get(PyObject* self, void* closure)
        -: 2859:{
    #####: 2860:    struct Row* row = (struct Row*)self;
    #####: 2861:    return ResultSetDescription_get_object(row->description);
call    0 never executed
        -: 2862:
    #####: 2863:    UNUSED(closure);
        -: 2864:}
        -: 2865:
        -: 2866:static PyGetSetDef Row_getset[] = {
        -: 2867:    /* name, get, set, doc, closure */
        -: 2868:    { (char*)"description", Row_description_get, NULL, (char*)s_Cursor_description_doc, NULL },
        -: 2869:    { NULL,                 NULL,                NULL, NULL,                            NULL }
        -: 2870:};
        -: 2871:
        -: 2872:static const char s_Row_dict_doc[] =
        -: 2873:    "dict()\n"
        -: 2874:    "\n"
        -: 2875:    "Get a dict representing the contents of the row. The keys will be column\n"
        -: 2876:    "names for columns that are named, and integer column numbers for those that\n"
        -: 2877:    "do not.\n"
        -: 2878:    "\n"
        -: 2879:    ":return: A dict representation of the row.\n";
        -: 2880:
function Row_dict called 0 returned 0% blocks executed 0%
    #####: 2881:static PyObject* Row_dict(PyObject* self, PyObject* args)
        -: 2882:{
    #####: 2883:    struct Row* row = (struct Row*)self;
    #####: 2884:    PyObject* dict = PyDict_New();
call    0 never executed
        -: 2885:
    #####: 2886:    if (dict)
branch  0 never executed
branch  1 never executed
        -: 2887:    {
    #####: 2888:        PyObject* description = ResultSetDescription_get_object(row->description);
call    0 never executed
    #####: 2889:        if (description)
branch  0 never executed
branch  1 never executed
        -: 2890:        {
    #####: 2891:            size_t ncolumns = row->description->ncolumns;
    #####: 2892:            size_t ix;
    #####: 2893:            assert((Py_ssize_t)ncolumns == PyTuple_GET_SIZE(description));
    #####: 2894:            for (ix = 0; ix < ncolumns; ++ix)
branch  0 never executed
branch  1 never executed
        -: 2895:            {
    #####: 2896:                PyObject* value = row->values[ix];
    #####: 2897:                PyObject* colname = Description_GET_ITEM(PyTuple_GET_ITEM(description, ix), 0);
    #####: 2898:                if (0 == PyObject_IsTrue(colname))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2899:                {
        -: 2900:                    /* Use the column number as the key for unnamed columns. */
    #####: 2901:                    PyObject* colnum = PyLong_FromSize_t(ix);
call    0 never executed
    #####: 2902:                    if (!colnum)
branch  0 never executed
branch  1 never executed
        -: 2903:                    {
        -: 2904:                        break;
        -: 2905:                    }
    #####: 2906:                    if (0 != PyDict_SetItem(dict, colnum, value))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2907:                    {
    #####: 2908:                        Py_DECREF(colnum);
branch  0 never executed
branch  1 never executed
        -: 2909:                        break;
        -: 2910:                    }
    #####: 2911:                    Py_DECREF(colnum);
branch  0 never executed
branch  1 never executed
        -: 2912:                }
        -: 2913:                else
        -: 2914:                {
        -: 2915:                    /* Use the column name as the key. */
    #####: 2916:                    if (0 != PyDict_SetItem(dict, colname, value))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2917:                    {
        -: 2918:                        break;
        -: 2919:                    }
        -: 2920:                }
        -: 2921:            }
    #####: 2922:            Py_DECREF(description);
branch  0 never executed
branch  1 never executed
        -: 2923:        }
        -: 2924:    }
        -: 2925:
    #####: 2926:    if (PyErr_Occurred())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2927:    {
    #####: 2928:        Py_XDECREF(dict);
    #####: 2929:        dict = NULL;
call    0 never executed
        -: 2930:    }
    #####: 2931:    return dict;
        -: 2932:
    #####: 2933:    UNUSED(args);
        -: 2934:}
        -: 2935:
        -: 2936:static PyMethodDef Row_methods[] = {
        -: 2937:    /* ml_name, ml_meth, ml_flags, ml_doc */
        -: 2938:    { "dict", Row_dict, METH_NOARGS, s_Row_dict_doc },
        -: 2939:    { NULL,   NULL,     0,           NULL }
        -: 2940:};
        -: 2941:
        -: 2942:static PyObject* Row_repr(PyObject* self)
        -: 2943:{
        -: 2944:    struct Row* row = (struct Row*)self;
        -: 2945:    size_t ncols = row->description->ncolumns;
        -: 2946:    PyObject* pieces = PyList_New(0);
        -: 2947:    size_t ix;
        -: 2948:
        -: 2949:    if (!pieces) return NULL;
        -: 2950:
        -: 2951:    for (ix = 0; ix < ncols; ++ix)
        -: 2952:    {
        -: 2953:        const char* colname = row->description->columns[ix].dbcol.ActualName;
        -: 2954:        PyObject* value_repr = PyObject_Repr(row->values[ix]);
        -: 2955:        PyObject* piece;
        -: 2956:
        -: 2957:        if (!value_repr)
        -: 2958:        {
        -: 2959:            Py_DECREF(pieces);
        -: 2960:            return NULL;
        -: 2961:        }
        -: 2962:
        -: 2963:        if (colname[0] != '\0')
        -: 2964:        {
        -: 2965:            piece = PyUnicode_FromFormat("%s=%U", colname, value_repr);
        -: 2966:        }
        -: 2967:        else
        -: 2968:        {
        -: 2969:            piece = PyUnicode_FromFormat("%U", value_repr);
        -: 2970:        }
        -: 2971:        Py_DECREF(value_repr);
        -: 2972:
        -: 2973:        if (!piece || PyList_Append(pieces, piece) == -1)
        -: 2974:        {
        -: 2975:            Py_XDECREF(piece);
        -: 2976:            Py_DECREF(pieces);
        -: 2977:            return NULL;
        -: 2978:        }
        -: 2979:        Py_DECREF(piece);
        -: 2980:    }
        -: 2981:
        -: 2982:    {
        -: 2983:        PyObject* sep = PyUnicode_FromString(", ");
        -: 2984:        PyObject* joined = sep ? PyUnicode_Join(sep, pieces) : NULL;
        -: 2985:        PyObject* result = joined
        -: 2986:            ? PyUnicode_FromFormat("<k_ctds.Row(%U)>", joined)
        -: 2987:            : NULL;
        -: 2988:        Py_XDECREF(sep);
        -: 2989:        Py_XDECREF(joined);
        -: 2990:        Py_DECREF(pieces);
        -: 2991:        return result;
        -: 2992:    }
        -: 2993:}
        -: 2994:
        -: 2995:#pragma GCC diagnostic push
        -: 2996:#pragma GCC diagnostic ignored "-Wmissing-field-initializers"
        -: 2997:PyTypeObject RowType = {
        -: 2998:    PyVarObject_HEAD_INIT(NULL, 0)
        -: 2999:    "k_ctds.Row",                               /* tp_name */
        -: 3000:    sizeof(struct Row),                       /* tp_basicsize */
        -: 3001:    sizeof(PyObject*),                        /* tp_itemsize */
        -: 3002:    Row_dealloc,                              /* tp_dealloc */
        -: 3003:#if PY_VERSION_HEX >= 0x03080000
        -: 3004:    0,                                        /* tp_vectorcall_offset */
        -: 3005:#else
        -: 3006:    NULL,                                     /* tp_print */
        -: 3007:#endif /* if PY_VERSION_HEX >= 0x03080000 */
        -: 3008:    NULL,                                     /* tp_getattr */
        -: 3009:    NULL,                                     /* tp_setattr */
        -: 3010:    NULL,                                     /* tp_reserved */
        -: 3011:    Row_repr,                                 /* tp_repr */
        -: 3012:    NULL,                                     /* tp_as_number */
        -: 3013:    &s_Row_as_sequence,                       /* tp_as_sequence */
        -: 3014:    &s_Row_as_mapping,                        /* tp_as_mapping */
        -: 3015:    NULL,                                     /* tp_hash */
        -: 3016:    NULL,                                     /* tp_call */
        -: 3017:    NULL,                                     /* tp_str */
        -: 3018:    Row_getattro,                             /* tp_getattro */
        -: 3019:    NULL,                                     /* tp_setattro */
        -: 3020:    NULL,                                     /* tp_as_buffer */
        -: 3021:    Py_TPFLAGS_DEFAULT,                       /* tp_flags */
        -: 3022:    NULL,                                     /* tp_doc */
        -: 3023:    NULL,                                     /* tp_traverse */
        -: 3024:    NULL,                                     /* tp_clear */
        -: 3025:    NULL,                                     /* tp_richcompare */
        -: 3026:    0,                                        /* tp_weaklistoffset */
        -: 3027:    NULL,                                     /* tp_iter */
        -: 3028:    NULL,                                     /* tp_iternext */
        -: 3029:    Row_methods,                              /* tp_methods */
function RowList_dealloc called 0 returned 0% blocks executed 0%
    #####: 3030:    NULL,                                     /* tp_members */
        -: 3031:    Row_getset,                               /* tp_getset */
    #####: 3032:    NULL,                                     /* tp_base */
    #####: 3033:    NULL,                                     /* tp_dict */
    #####: 3034:    NULL,                                     /* tp_descr_get */
branch  0 never executed
branch  1 never executed
        -: 3035:    NULL,                                     /* tp_descr_set */
    #####: 3036:    0,                                        /* tp_dictoffset */
branch  0 never executed
branch  1 never executed
        -: 3037:    NULL,                                     /* tp_init */
    #####: 3038:    NULL,                                     /* tp_alloc */
branch  0 never executed
branch  1 never executed
        -: 3039:    NULL,                                     /* tp_new */
        -: 3040:    NULL,                                     /* tp_free */
        -: 3041:    NULL,                                     /* tp_is_gc */
    #####: 3042:    NULL,                                     /* tp_bases */
call    0 never executed
        -: 3043:    NULL,                                     /* tp_mro */
        -: 3044:    NULL,                                     /* tp_cache */
        -: 3045:    NULL,                                     /* tp_subclasses */
        -: 3046:    NULL,                                     /* tp_weaklist */
    #####: 3047:    NULL,                                     /* tp_del */
call    0 never executed
        -: 3048:    0,                                        /* tp_version_tag */
    #####: 3049:#if PY_VERSION_HEX >= 0x03040000
call    0 never executed
    #####: 3050:    NULL,                                     /* tp_finalize */
        -: 3051:#endif /* if PY_VERSION_HEX >= 0x03040000 */
        -: 3052:#if PY_VERSION_HEX >= 0x03080000
function RowList_create called 0 returned 0% blocks executed 0%
    #####: 3053:    NULL,                                     /* tp_vectorcall */
        -: 3054:#  if PY_VERSION_HEX < 0x03090000
        -: 3055:    NULL,                                     /* tp_print */
        -: 3056:#  endif /* if PY_VERSION_HEX < 0x03090000 */
    #####: 3057:#endif /* if PY_VERSION_HEX >= 0x03080000 */
call    0 never executed
    #####: 3058:};
branch  0 never executed
branch  1 never executed
        -: 3059:#pragma GCC diagnostic pop
    #####: 3060:
        -: 3061:/* Stores the `struct RowBuffer` for a row until requested by the client. */
    #####: 3062:struct LazilyCreatedRow {
    #####: 3063:    bool converted;
        -: 3064:    union {
    #####: 3065:      PyObject* python;
branch  0 never executed
branch  1 never executed
        -: 3066:      struct RowBuffer* rowbuffer;
    #####: 3067:    } row;
    #####: 3068:};
    #####: 3069:
    #####: 3070:static const char s_RowList_description_doc[] =
    #####: 3071:    "A :ref:`sequence <python:sequence>` object which buffers result set rows\n"
        -: 3072:    "in a lightweight manner. Python objects wrapping the columnar data are\n"
        -: 3073:    "only created when the data is actually accessed.\n";
        -: 3074:
        -: 3075:struct RowList {
        -: 3076:    PyObject_VAR_HEAD
    #####: 3077:
call    0 never executed
        -: 3078:    struct ResultSetDescription* description;
    #####: 3079:
        -: 3080:    struct LazilyCreatedRow rows[1]; /* space for rows is added by tp_alloc() */
        -: 3081:};
function RowList_len called 0 returned 0% blocks executed 0%
    #####: 3082:
        -: 3083:static void RowList_dealloc(PyObject* self)
    #####: 3084:{
        -: 3085:    struct RowList* rowlist = (struct RowList*)self;
        -: 3086:    Py_ssize_t ix;
function RowList_item called 0 returned 0% blocks executed 0%
    #####: 3087:    for (ix = 0; ix < Py_SIZE(self); ++ix)
        -: 3088:    {
    #####: 3089:        if (rowlist->rows[ix].converted)
        -: 3090:        {
        -: 3091:            Py_DECREF(rowlist->rows[ix].row.python);
        -: 3092:        }
        -: 3093:        else
        -: 3094:        {
    #####: 3095:            ResultSetDescription_RowBuffer_free(rowlist->description,
    #####: 3096:                                                rowlist->rows[ix].row.rowbuffer);
branch  0 never executed
branch  1 never executed
        -: 3097:        }
    #####: 3098:    }
    #####: 3099:
call    0 never executed
        -: 3100:    ResultSetDescription_decrement(rowlist->description);
        -: 3101:
        -: 3102:    PyObject_Del(self);
        -: 3103:}
        -: 3104:
        -: 3105:PyTypeObject RowListType; /* forward decl. */
    #####: 3106:static struct RowList* RowList_create(struct ResultSetDescription* description,
branch  0 never executed
branch  1 never executed
        -: 3107:                                      size_t nrows,
    #####: 3108:                                      struct RowBuffer* rowbuffers)
    #####: 3109:{
call    0 never executed
    #####: 3110:    struct RowList* rowlist = PyObject_NewVar(struct RowList, &RowListType, (Py_ssize_t)nrows);
branch  0 never executed
branch  1 never executed
        -: 3111:    if (rowlist)
        -: 3112:    {
        -: 3113:        size_t ix = 0;
        -: 3114:
        -: 3115:        rowlist->description = description;
    #####: 3116:        ResultSetDescription_increment(description);
call    0 never executed
        -: 3117:
        -: 3118:        while (rowbuffers)
    #####: 3119:        {
    #####: 3120:            rowlist->rows[ix].converted = false;
        -: 3121:            rowlist->rows[ix].row.rowbuffer = rowbuffers;
    #####: 3122:            rowbuffers = rowbuffers->next;
branch  0 never executed
branch  1 never executed
        -: 3123:            rowlist->rows[ix].row.rowbuffer->next = NULL;
        -: 3124:            ++ix;
        -: 3125:        }
function RowList_description_get called 0 returned 0% blocks executed 0%
    #####: 3126:        assert(ix == nrows);
        -: 3127:    }
    #####: 3128:    else
    #####: 3129:    {
call    0 never executed
        -: 3130:        PyErr_NoMemory();
    #####: 3131:    }
        -: 3132:    return rowlist;
        -: 3133:}
        -: 3134:
        -: 3135:static Py_ssize_t RowList_len(PyObject* self)
        -: 3136:{
        -: 3137:    return Py_SIZE(self);
        -: 3138:}
        -: 3139:
function RowListType_init called 0 returned 0% blocks executed 0%
    #####: 3140:static PyObject* RowList_item(PyObject* self, Py_ssize_t ix)
        -: 3141:{
    #####: 3142:    struct RowList* rowlist = (struct RowList*)self;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3143:    /*
    #####: 3144:        ix should always be >= 0 because `sq_length` is provided.
        -: 3145:
        -: 3146:        See https://docs.python.org/3.6/c-api/typeobj.html#sequence-object-structures
        -: 3147:    */
        -: 3148:    assert(ix >= 0);
        -: 3149:    if (ix >= Py_SIZE(self))
        -: 3150:    {
        -: 3151:        PyErr_SetString(PyExc_IndexError, "index is out of range");
        -: 3152:        return NULL;
        -: 3153:    }
        -: 3154:
        -: 3155:    /*
        -: 3156:        Convert the `struct RowBuffer` raw data to a Python object on
        -: 3157:        first access.
        -: 3158:    */
        -: 3159:    if (!rowlist->rows[ix].converted)
        -: 3160:    {
        -: 3161:        struct RowBuffer* rowbuffer = rowlist->rows[ix].row.rowbuffer;
        -: 3162:        struct Row* row = Row_create(rowlist->description, rowbuffer);
        -: 3163:        if (!row)
        -: 3164:        {
        -: 3165:            assert(PyErr_Occurred());
        -: 3166:            return NULL;
        -: 3167:        }
        -: 3168:
        -: 3169:        ResultSetDescription_RowBuffer_free(rowlist->description,
        -: 3170:                                            rowbuffer);
        -: 3171:
        -: 3172:        rowlist->rows[ix].row.python = (PyObject*)row; /* claim reference */
        -: 3173:        rowlist->rows[ix].converted = true;
        -: 3174:    }
        -: 3175:    Py_INCREF(rowlist->rows[ix].row.python);
        -: 3176:    return rowlist->rows[ix].row.python;
        -: 3177:}
        -: 3178:
        -: 3179:static PyObject* RowList_description_get(PyObject* self, void* closure)
        -: 3180:{
        -: 3181:    struct RowList* rowlist = (struct RowList*)self;
        -: 3182:    return ResultSetDescription_get_object(rowlist->description);
        -: 3183:
        -: 3184:    UNUSED(closure);
        -: 3185:}
        -: 3186:
        -: 3187:static PyGetSetDef RowList_getset[] = {
        -: 3188:    /* name, get, set, doc, closure */
        -: 3189:    { (char*)"description", RowList_description_get, NULL, (char*)s_Cursor_description_doc, NULL },
        -: 3190:    { NULL,                 NULL,                    NULL, NULL,                            NULL }
        -: 3191:};
        -: 3192:
        -: 3193:PyTypeObject* RowListType_init(void)
        -: 3194:{
        -: 3195:    if (0 != PyType_Ready(&RowListType))
        -: 3196:    {
        -: 3197:        return NULL;
        -: 3198:    }
        -: 3199:    return &RowListType;
        -: 3200:}
        -: 3201:
        -: 3202:static PySequenceMethods s_RowList_as_sequence = {
        -: 3203:    RowList_len,  /* sq_length */
        -: 3204:    NULL,         /* sq_concat */
        -: 3205:    NULL,         /* sq_repeat */
        -: 3206:    RowList_item, /* sq_item */
        -: 3207:    NULL,         /* sq_ass_item */
        -: 3208:    NULL,         /* was_sq_slice */
        -: 3209:    NULL,         /* sq_contains */
        -: 3210:    NULL,         /* was_sq_ass_slice */
        -: 3211:    NULL,         /* sq_inplace_concat */
        -: 3212:    NULL,         /* sq_inplace_repeat */
        -: 3213:};
        -: 3214:
        -: 3215:#pragma GCC diagnostic push
        -: 3216:#pragma GCC diagnostic ignored "-Wmissing-field-initializers"
        -: 3217:PyTypeObject RowListType = {
        -: 3218:    PyVarObject_HEAD_INIT(NULL, 0)
        -: 3219:    "k_ctds.RowList",                           /* tp_name */
        -: 3220:    sizeof(struct RowList),                   /* tp_basicsize */
        -: 3221:    sizeof(struct LazilyCreatedRow),          /* tp_itemsize */
        -: 3222:    RowList_dealloc,                          /* tp_dealloc */
        -: 3223:#if PY_VERSION_HEX >= 0x03080000
        -: 3224:    0,                                        /* tp_vectorcall_offset */
        -: 3225:#else
        -: 3226:    NULL,                                     /* tp_print */
        -: 3227:#endif /* if PY_VERSION_HEX >= 0x03080000 */
        -: 3228:    NULL,                                     /* tp_getattr */
        -: 3229:    NULL,                                     /* tp_setattr */
        -: 3230:    NULL,                                     /* tp_reserved */
        -: 3231:    NULL,                                     /* tp_repr */
        -: 3232:    NULL,                                     /* tp_as_number */
        -: 3233:    &s_RowList_as_sequence,                   /* tp_as_sequence */
        -: 3234:    NULL,                                     /* tp_as_mapping */
        -: 3235:    NULL,                                     /* tp_hash */
        -: 3236:    NULL,                                     /* tp_call */
        -: 3237:    NULL,                                     /* tp_str */
        -: 3238:    NULL,                                     /* tp_getattro */
        -: 3239:    NULL,                                     /* tp_setattro */
        -: 3240:    NULL,                                     /* tp_as_buffer */
        -: 3241:    Py_TPFLAGS_DEFAULT,                       /* tp_flags */
        -: 3242:    s_RowList_description_doc,                /* tp_doc */
        -: 3243:    NULL,                                     /* tp_traverse */
        -: 3244:    NULL,                                     /* tp_clear */
        -: 3245:    NULL,                                     /* tp_richcompare */
        -: 3246:    0,                                        /* tp_weaklistoffset */
        -: 3247:    NULL,                                     /* tp_iter */
function Cursor_fetchrows called 0 returned 0% blocks executed 0%
    #####: 3248:    NULL,                                     /* tp_iternext */
        -: 3249:    NULL,                                     /* tp_methods */
    #####: 3250:    NULL,                                     /* tp_members */
        -: 3251:    RowList_getset,                           /* tp_getset */
        -: 3252:    NULL,                                     /* tp_base */
    #####: 3253:    NULL,                                     /* tp_dict */
    #####: 3254:    NULL,                                     /* tp_descr_get */
    #####: 3255:    NULL,                                     /* tp_descr_set */
branch  0 never executed
branch  1 never executed
        -: 3256:    0,                                        /* tp_dictoffset */
    #####: 3257:    NULL,                                     /* tp_init */
        -: 3258:    NULL,                                     /* tp_alloc */
    #####: 3259:    NULL,                                     /* tp_new */
call    0 never executed
        -: 3260:    NULL,                                     /* tp_free */
        -: 3261:    NULL,                                     /* tp_is_gc */
    #####: 3262:    NULL,                                     /* tp_bases */
branch  0 never executed
branch  1 never executed
        -: 3263:    NULL,                                     /* tp_mro */
    #####: 3264:    NULL,                                     /* tp_cache */
    #####: 3265:    NULL,                                     /* tp_subclasses */
call    0 never executed
        -: 3266:    NULL,                                     /* tp_weaklist */
        -: 3267:    NULL,                                     /* tp_del */
    #####: 3268:    0,                                        /* tp_version_tag */
        -: 3269:#if PY_VERSION_HEX >= 0x03040000
    #####: 3270:    NULL,                                     /* tp_finalize */
    #####: 3271:#endif /* if PY_VERSION_HEX >= 0x03040000 */
    #####: 3272:#if PY_VERSION_HEX >= 0x03080000
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3273:    NULL,                                     /* tp_vectorcall */
        -: 3274:#  if PY_VERSION_HEX < 0x03090000
    #####: 3275:    NULL,                                     /* tp_print */
        -: 3276:#  endif /* if PY_VERSION_HEX < 0x03090000 */
    #####: 3277:#endif /* if PY_VERSION_HEX >= 0x03080000 */
        -: 3278:};
    #####: 3279:#pragma GCC diagnostic pop
call    0 never executed
    #####: 3280:
branch  0 never executed
branch  1 never executed
        -: 3281:#define FETCH_ALL ((size_t)-1)
        -: 3282:
        -: 3283:/*
    #####: 3284:    Fetch rows for the current result set.
        -: 3285:
    #####: 3286:    This method wil fetch and buffer all requested rows without holding
    #####: 3287:    the GIL. While this is more memory intensive, it does provide much better
branch  0 never executed
branch  1 never executed
        -: 3288:    throughput. In applications with many Python threads, constantly acquiring
    #####: 3289:    and releasing the GIL can be expensive. Multiple threads, each requesting
    #####: 3290:    large resultsets, can lead to massive GIL churn and poor performance.
    #####: 3291:
call    0 never executed
        -: 3292:    @note This method sets an appropriate Python exception on error.
    #####: 3293:    @note This method returns a new reference.
        -: 3294:
    #####: 3295:    @param cursor [in] The cursor.
branch  0 never executed
branch  1 never executed
        -: 3296:    @param n [in] The number of rows to fetch from the server.
        -: 3297:
        -: 3298:    @return A `struct RowList` object.
        -: 3299:    @return NULL on failure.
        -: 3300:*/
    #####: 3301:static struct RowList* Cursor_fetchrows(struct Cursor* cursor, size_t n)
    #####: 3302:{
        -: 3303:    RETCODE retcode = NO_MORE_ROWS;
        -: 3304:
    #####: 3305:    /* Buffer all rows. */
branch  0 never executed
branch  1 never executed
        -: 3306:    struct RowBuffer* rowbuffers = NULL;
    #####: 3307:    struct ResultSetDescription* description = cursor->description;
    #####: 3308:    size_t rowsize = ResultSetDescription_RowBuffer_size(description);
        -: 3309:
    #####: 3310:    size_t rows; /* count of rows processed */
    #####: 3311:
        -: 3312:    DBPROCESS* dbproc = Connection_DBPROCESS(cursor->connection);
    #####: 3313:
        -: 3314:    /* Verify there are results */
    #####: 3315:    if (!cursor->description)
branch  0 never executed
branch  1 never executed
        -: 3316:    {
    #####: 3317:        PyErr_Format(PyExc_tds_InterfaceError, "no results");
    #####: 3318:        return NULL;
call    0 never executed
    #####: 3319:    }
call    0 never executed
        -: 3320:
        -: 3321:    Py_BEGIN_ALLOW_THREADS
        -: 3322:    {
        -: 3323:        struct RowBuffer* last_rowbuffer = NULL;
    #####: 3324:        size_t colnum;
call    0 never executed
    #####: 3325:        for (rows = 0; rows < n || FETCH_ALL == n; ++rows)
branch  0 never executed
branch  1 never executed
        -: 3326:        {
    #####: 3327:            /* The offset to the next column buffer in the row. */
    #####: 3328:            size_t offset = 0;
call    0 never executed
    #####: 3329:
call    0 never executed
        -: 3330:            struct RowBuffer* new_rowbuffer;
        -: 3331:
        -: 3332:            retcode = dbnextrow(dbproc);
        -: 3333:            if ((NO_MORE_ROWS == retcode) || (FAIL == retcode))
    #####: 3334:            {
    #####: 3335:                break;
    #####: 3336:            }
        -: 3337:            assert(BUF_FULL != retcode);
        -: 3338:
        -: 3339:            new_rowbuffer = tds_mem_malloc(rowsize);
    #####: 3340:            if (!new_rowbuffer)
branch  0 never executed
branch  1 never executed
        -: 3341:            {
        -: 3342:                ResultSetDescription_RowBuffer_free(description, rowbuffers);
        -: 3343:                rowbuffers = NULL;
        -: 3344:                break;
        -: 3345:            }
    #####: 3346:            memset(new_rowbuffer, 0, rowsize);
branch  0 never executed
branch  1 never executed
        -: 3347:
    #####: 3348:            if (!rowbuffers)
    #####: 3349:            {
branch  0 never executed
branch  1 never executed
        -: 3350:                rowbuffers = last_rowbuffer = new_rowbuffer;
    #####: 3351:            }
    #####: 3352:            else
    #####: 3353:            {
call    0 never executed
        -: 3354:                last_rowbuffer->next = new_rowbuffer;
        -: 3355:                last_rowbuffer = new_rowbuffer;
    #####: 3356:            }
        -: 3357:
        -: 3358:            for (colnum = 1; colnum <= description->ncolumns; ++colnum)
        -: 3359:            {
        -: 3360:                const struct Column* column = &description->columns[colnum - 1];
    #####: 3361:                struct ColumnBuffer* colbuffer = (struct ColumnBuffer*)(((char*)last_rowbuffer->columns) + offset);
        -: 3362:
    #####: 3363:                const BYTE* data;
    #####: 3364:                DBINT ndata;
        -: 3365:
    #####: 3366:                void* dest;
branch  0 never executed
branch  1 never executed
        -: 3367:
        -: 3368:                if (REG_ROW == retcode)
        -: 3369:                {
    #####: 3370:                    colbuffer->tdstype = (enum TdsType)column->dbcol.Type;
call    0 never executed
        -: 3371:                    data = dbdata(dbproc, (DBINT)colnum);
        -: 3372:                    ndata = dbdatlen(dbproc, (DBINT)colnum);
    #####: 3373:                }
        -: 3374:                else
    #####: 3375:                {
branch  0 never executed
branch  1 never executed
        -: 3376:                    /* retcode is a compute ID. */
    #####: 3377:                    int type = dbalttype(dbproc, retcode, (DBINT)colnum);
branch  0 never executed
branch  1 never executed
        -: 3378:                    if (-1 != type)
    #####: 3379:                    {
    #####: 3380:                        colbuffer->tdstype = (enum TdsType)type;
call    0 never executed
        -: 3381:                        data = dbadata(dbproc, retcode, (DBINT)colnum);
        -: 3382:                        ndata = dbadlen(dbproc, retcode, (DBINT)colnum);
        -: 3383:                    }
    #####: 3384:                    else
branch  0 never executed
branch  1 never executed
        -: 3385:                    {
    #####: 3386:                        /* For missing compute columns, return None. */
call    0 never executed
    #####: 3387:                        colbuffer->tdstype = (enum TdsType)column->dbcol.Type;
    #####: 3388:                        data = NULL;
call    0 never executed
        -: 3389:                        ndata = 0;
        -: 3390:                    }
        -: 3391:                }
    #####: 3392:
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3393:                if (Column_IsVariableLength(&column->dbcol))
        -: 3394:                {
        -: 3395:                    /*
        -: 3396:                        Allocate a buffer for the variable length data.
        -: 3397:                        `data` will be NULL if the value is NULL.
    #####: 3398:                    */
call    0 never executed
        -: 3399:                    if (data)
        -: 3400:                    {
        -: 3401:                        colbuffer->data.variable = tds_mem_malloc((size_t)ndata);
        -: 3402:                        if (!colbuffer->data.variable)
        -: 3403:                        {
        -: 3404:                            ResultSetDescription_RowBuffer_free(description, rowbuffers);
        -: 3405:                            rowbuffers = NULL;
        -: 3406:                            break;
        -: 3407:                        }
        -: 3408:                    }
        -: 3409:                    dest = colbuffer->data.variable;
        -: 3410:                }
        -: 3411:                else
        -: 3412:                {
function Cursor_fetchone called 0 returned 0% blocks executed 0%
    #####: 3413:                    /* Fixed length data buffer was allocated as part of the row buffer. */
        -: 3414:                    dest = &colbuffer->data.fixed;
    #####: 3415:                }
    #####: 3416:                colbuffer->size = (size_t)ndata;
    #####: 3417:                memcpy(dest, data, colbuffer->size);
        -: 3418:
    #####: 3419:                offset += ColumnBuffer_size(&column->dbcol);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 3420:            }
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 3421:        }
    #####: 3422:    }
call    0 never executed
    #####: 3423:    Py_END_ALLOW_THREADS
branch  0 never executed
branch  1 never executed
        -: 3424:
    #####: 3425:    /* Update the rows read count before returning any errors. */
branch  0 never executed
branch  1 never executed
        -: 3426:    cursor->rowsread += rows;
    #####: 3427:
call    0 never executed
        -: 3428:    if (NO_MORE_ROWS != retcode)
        -: 3429:    {
        -: 3430:        if (!rowbuffers)
    #####: 3431:        {
    #####: 3432:            PyErr_NoMemory();
branch  0 never executed
branch  1 never executed
        -: 3433:            return NULL;
    #####: 3434:        }
branch  0 never executed
branch  1 never executed
        -: 3435:    }
        -: 3436:
        -: 3437:    if (FAIL == retcode)
    #####: 3438:    {
        -: 3439:        ResultSetDescription_RowBuffer_free(description, rowbuffers);
        -: 3440:        Connection_raise_lasterror(cursor->connection);
        -: 3441:        return NULL;
        -: 3442:    }
        -: 3443:
        -: 3444:    /* Raise any warning messages which may have occurred. */
        -: 3445:    if (0 != Connection_raise_lastwarning(cursor->connection))
        -: 3446:    {
        -: 3447:        assert(PyErr_Occurred());
        -: 3448:        ResultSetDescription_RowBuffer_free(description, rowbuffers);
        -: 3449:        return NULL;
        -: 3450:    }
        -: 3451:
        -: 3452:    return RowList_create(description, rows, rowbuffers);
function Cursor_fetchmany called 0 returned 0% blocks executed 0%
    #####: 3453:}
        -: 3454:
    #####: 3455:
        -: 3456:/* https://www.python.org/dev/peps/pep-0249/#fetchone */
    #####: 3457:static const char s_Cursor_fetchone_doc[] =
        -: 3458:    "fetchone()\n"
        -: 3459:    "\n"
        -: 3460:    "Fetch the next row of a query result set, returning a single sequence, or\n"
        -: 3461:    ":py:data:`None` when no more data is available.\n"
    #####: 3462:    "\n"
    #####: 3463:    ":pep:`0249#fetchone`\n"
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3464:    "\n"
        -: 3465:    ":return: The next row or :py:data:`None`.\n";
        -: 3466:
    #####: 3467:static PyObject* Cursor_fetchone(PyObject* self, PyObject* args)
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 3468:{
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 3469:    struct Cursor* cursor = (struct Cursor*)self;
    #####: 3470:    struct RowList* rowlist;
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 3471:    PyObject* row = NULL;
        -: 3472:
        -: 3473:    Cursor_verify_open(cursor);
        -: 3474:    Cursor_verify_connection_open(cursor);
        -: 3475:
        -: 3476:    rowlist = Cursor_fetchrows(cursor, 1);
        -: 3477:    if (rowlist)
        -: 3478:    {
        -: 3479:        if (Py_SIZE(rowlist) > 0)
        -: 3480:        {
        -: 3481:            row = RowList_item((PyObject*)rowlist, 0);
        -: 3482:        }
        -: 3483:        else
        -: 3484:        {
function Cursor_fetchall called 0 returned 0% blocks executed 0%
    #####: 3485:            row = Py_None;
        -: 3486:            Py_INCREF(row);
    #####: 3487:        }
    #####: 3488:        Py_DECREF(rowlist);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 3489:    }
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 3490:
    #####: 3491:    return row;
call    0 never executed
    #####: 3492:    UNUSED(args);
        -: 3493:}
        -: 3494:
        -: 3495:/* https://www.python.org/dev/peps/pep-0249/#fetchmany */
        -: 3496:static const char s_Cursor_fetchmany_doc[] =
        -: 3497:    "fetchmany(size=self.arraysize)\n"
        -: 3498:    "\n"
        -: 3499:    "Fetch the next set of rows of a query result, returning a sequence of\n"
        -: 3500:    "sequences. An empty sequence is returned when no more rows are available.\n"
        -: 3501:    "\n"
        -: 3502:    ":pep:`0249#fetchmany`\n"
        -: 3503:    "\n"
        -: 3504:    ":return: A sequence of result rows.\n"
        -: 3505:    ":rtype: k_ctds.RowList\n";
        -: 3506:
        -: 3507:static PyObject* Cursor_fetchmany(PyObject* self, PyObject* args, PyObject* kwargs)
        -: 3508:{
function Cursor_nextset called 0 returned 0% blocks executed 0%
    #####: 3509:    struct Cursor* cursor = (struct Cursor*)self;
        -: 3510:
    #####: 3511:    static char* s_kwlist[] =
    #####: 3512:    {
        -: 3513:        "size",
    #####: 3514:        NULL
    #####: 3515:    };
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 3516:    unsigned PY_LONG_LONG size = 0;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 3517:    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|K", s_kwlist, &size))
branch  0 never executed
branch  1 never executed
        -: 3518:    {
    #####: 3519:        return NULL;
call    0 never executed
        -: 3520:    }
    #####: 3521:    Cursor_verify_open(cursor);
call    0 never executed
        -: 3522:    Cursor_verify_connection_open(cursor);
    #####: 3523:
call    0 never executed
        -: 3524:    return (PyObject*)Cursor_fetchrows(cursor, (size_t)((size) ? size : cursor->arraysize));
    #####: 3525:}
branch  0 never executed
branch  1 never executed
        -: 3526:
    #####: 3527:/* https://www.python.org/dev/peps/pep-0249/#fetchall */
branch  0 never executed
branch  1 never executed
        -: 3528:static const char s_Cursor_fetchall_doc[] =
    #####: 3529:    "fetchall()\n"
call    0 never executed
        -: 3530:    "\n"
        -: 3531:    "Fetch all (remaining) rows of a query result, returning them as a\n"
        -: 3532:    "sequence of sequences.\n"
        -: 3533:    "\n"
    #####: 3534:    ":pep:`0249#fetchall`\n"
call    0 never executed
        -: 3535:    "\n"
    #####: 3536:    ":return: A sequence of result rows.\n"
        -: 3537:    ":rtype: k_ctds.RowList\n";
        -: 3538:
    #####: 3539:static PyObject* Cursor_fetchall(PyObject* self, PyObject* args)
branch  0 never executed
branch  1 never executed
        -: 3540:{
        -: 3541:    struct Cursor* cursor = (struct Cursor*)self;
        -: 3542:    Cursor_verify_open(cursor);
        -: 3543:    Cursor_verify_connection_open(cursor);
        -: 3544:
    #####: 3545:    return (PyObject*)Cursor_fetchrows(cursor, FETCH_ALL);
        -: 3546:    UNUSED(args);
    #####: 3547:}
        -: 3548:
        -: 3549:/* https://www.python.org/dev/peps/pep-0249/#nextset */
        -: 3550:static const char s_Cursor_nextset_doc[] =
        -: 3551:    "nextset()\n"
        -: 3552:    "\n"
        -: 3553:    "Skip to the next available set, discarding any remaining rows from the\n"
        -: 3554:    "current set.\n"
        -: 3555:    "\n"
        -: 3556:    ":pep:`0249#nextset`\n"
        -: 3557:    "\n"
function Cursor_setinputsizes called 0 returned 0% blocks executed 0%
    #####: 3558:    ":return:\n"
        -: 3559:    "    :py:data:`True` if there was another result set or :py:data:`None`\n"
    #####: 3560:    "    if not.\n"
    #####: 3561:    ":rtype: bool\n";
    #####: 3562:
        -: 3563:static PyObject* Cursor_nextset(PyObject* self, PyObject* args)
        -: 3564:{
        -: 3565:    RETCODE retcode;
        -: 3566:    int error;
        -: 3567:
        -: 3568:    struct Cursor* cursor = (struct Cursor*)self;
        -: 3569:    Cursor_verify_open(cursor);
        -: 3570:    Cursor_verify_connection_open(cursor);
        -: 3571:    Cursor_clear_resultset(cursor);
        -: 3572:
function Cursor_setoutputsize called 0 returned 0% blocks executed 0%
    #####: 3573:    Py_BEGIN_ALLOW_THREADS
        -: 3574:
    #####: 3575:        error = Cursor_next_resultset(cursor, &retcode);
    #####: 3576:
    #####: 3577:    Py_END_ALLOW_THREADS
        -: 3578:
        -: 3579:    if (error)
        -: 3580:    {
        -: 3581:        if (FAIL == retcode)
        -: 3582:        {
        -: 3583:            Connection_raise_lasterror(cursor->connection);
        -: 3584:        }
        -: 3585:        else
        -: 3586:        {
        -: 3587:            /* Assume out of memory. */
        -: 3588:            PyErr_NoMemory();
        -: 3589:        }
        -: 3590:        return NULL;
        -: 3591:    }
        -: 3592:
        -: 3593:    if (cursor->description)
function Cursor_next_internal called 0 returned 0% blocks executed 0%
    #####: 3594:    {
        -: 3595:        Py_RETURN_TRUE;
    #####: 3596:    }
call    0 never executed
    #####: 3597:    else
branch  0 never executed
branch  1 never executed
        -: 3598:    {
    #####: 3599:        Py_RETURN_NONE;
call    0 never executed
    #####: 3600:    }
branch  0 never executed
branch  1 never executed
        -: 3601:    UNUSED(args);
        -: 3602:}
    #####: 3603:
        -: 3604:/* https://www.python.org/dev/peps/pep-0249/#setinputsizes */
        -: 3605:static const char s_Cursor_setinputsizes_doc[] =
function Cursor_next called 0 returned 0% blocks executed 0%
    #####: 3606:    "setinputsizes()\n"
        -: 3607:    "\n"
    #####: 3608:    "This method has no effect.\n"
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3609:    "\n"
        -: 3610:    ":pep:`0249#setinputsizes`\n";
        -: 3611:
    #####: 3612:static PyObject* Cursor_setinputsizes(PyObject* self, PyObject* args)
call    0 never executed
        -: 3613:{
        -: 3614:    Py_RETURN_NONE;
        -: 3615:    UNUSED(self);
        -: 3616:    UNUSED(args);
        -: 3617:}
        -: 3618:
        -: 3619:/* https://www.python.org/dev/peps/pep-0249/#setoutputsize */
        -: 3620:static const char s_Cursor_setoutputsize_doc[] =
        -: 3621:    "setoutputsize()\n"
        -: 3622:    "\n"
        -: 3623:    "This method has no effect.\n"
function Cursor___enter__ called 0 returned 0% blocks executed 0%
    #####: 3624:    "\n"
        -: 3625:    ":pep:`0249#setoutputsize`\n";
    #####: 3626:
branch  0 never executed
branch  1 never executed
        -: 3627:static PyObject* Cursor_setoutputsize(PyObject* self, PyObject* args)
    #####: 3628:{
    #####: 3629:    Py_RETURN_NONE;
        -: 3630:    UNUSED(self);
        -: 3631:    UNUSED(args);
        -: 3632:}
        -: 3633:
        -: 3634:/* https://www.python.org/dev/peps/pep-0249/#next */
        -: 3635:static const char s_Cursor_next_doc[] =
        -: 3636:    "next()\n"
        -: 3637:    "\n"
        -: 3638:    "Return the next row from the currently executing SQL statement using the\n"
        -: 3639:    "same semantics as :py:meth:`.fetchone`. A :py:exc:`StopIteration` exception\n"
        -: 3640:    "is raised when the result set is exhausted.\n"
        -: 3641:    "\n"
        -: 3642:    ":pep:`0249#next`\n"
        -: 3643:    "\n"
        -: 3644:    ":raises StopIteration: The result set is exhausted.\n"
        -: 3645:    "\n"
function Cursor___exit__ called 0 returned 0% blocks executed 0%
    #####: 3646:    ":return: The next row.\n";
        -: 3647:
    #####: 3648:static PyObject* Cursor_next_internal(PyObject* self, PyObject* args)
call    0 never executed
    #####: 3649:{
        -: 3650:    PyObject* row = Cursor_fetchone(self, args);
        -: 3651:    if (Py_None == row)
        -: 3652:    {
        -: 3653:        PyErr_SetNone(PyExc_StopIteration);
        -: 3654:        Py_DECREF(row);
        -: 3655:        row = NULL;
        -: 3656:    }
        -: 3657:    return row;
        -: 3658:}
        -: 3659:
        -: 3660:static PyObject* Cursor_next(PyObject* self, PyObject* args)
        -: 3661:{
        -: 3662:    if (0 != warn_extension_used("cursor.next()"))
        -: 3663:    {
        -: 3664:        return NULL;
        -: 3665:    }
        -: 3666:    return Cursor_next_internal(self, args);
        -: 3667:}
        -: 3668:
        -: 3669:static const char s_Cursor___enter___doc[] =
        -: 3670:    "__enter__()\n"
        -: 3671:    "\n"
        -: 3672:    "Enter the cursor's runtime context. On exit, the cursor is\n"
        -: 3673:    "closed automatically.\n"
        -: 3674:    "\n"
        -: 3675:    ":return: The cursor object.\n"
        -: 3676:    ":rtype: k_ctds.Cursor\n";
        -: 3677:
        -: 3678:static PyObject* Cursor___enter__(PyObject* self, PyObject* args)
        -: 3679:{
        -: 3680:    Py_INCREF(self);
        -: 3681:
        -: 3682:    return self;
        -: 3683:    UNUSED(args);
        -: 3684:}
        -: 3685:
        -: 3686:static const char s_Cursor___exit___doc[] =
        -: 3687:    "__exit__(exc_type, exc_val, exc_tb)\n"
        -: 3688:    "\n"
        -: 3689:    "Exit the cursor's runtime context, closing the cursor.\n"
        -: 3690:    "\n"
function Cursor_iter called 0 returned 0% blocks executed 0%
    #####: 3691:    ":param type exc_type: The exception type, if an exception\n"
        -: 3692:    "    is raised in the context, otherwise :py:data:`None`.\n"
    #####: 3693:    ":param Exception exc_val: The exception value, if an exception\n"
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3694:    "    is raised in the context, otherwise :py:data:`None`.\n"
        -: 3695:    ":param object exc_tb: The exception traceback, if an exception\n"
        -: 3696:    "    is raised in the context, otherwise :py:data:`None`.\n"
    #####: 3697:    "\n"
branch  0 never executed
branch  1 never executed
        -: 3698:    ":returns: :py:data:`None`\n";
        -: 3699:
        -: 3700:static PyObject* Cursor___exit__(PyObject* self, PyObject* args)
function Cursor_iternext called 0 returned 0% blocks executed 0%
    #####: 3701:{
        -: 3702:    return Cursor_close(self, NULL);
    #####: 3703:    UNUSED(args);
call    0 never executed
        -: 3704:}
        -: 3705:
function Cursor_create called 0 returned 0% blocks executed 0%
    #####: 3706:#if defined(__GNUC__) && (__GNUC__ > 7)
        -: 3707:#  pragma GCC diagnostic push
    #####: 3708:#  pragma GCC diagnostic ignored "-Wcast-function-type"
call    0 never executed
    #####: 3709:#endif /* if defined(__GNUC__) && (__GNUC__ > 7) */
branch  0 never executed
branch  1 never executed
        -: 3710:
    #####: 3711:static PyMethodDef Cursor_methods[] = {
        -: 3712:    /* ml_name, ml_meth, ml_flags, ml_doc */
        -: 3713:    /* DB API-2.0 required methods. */
        -: 3714:    { "callproc",      Cursor_callproc,              METH_VARARGS,                  s_Cursor_callproc_doc },
        -: 3715:    { "close",         Cursor_close,                 METH_NOARGS,                   s_Cursor_close_doc },
        -: 3716:    { "execute",       Cursor_execute,               METH_VARARGS,                  s_Cursor_execute_doc },
        -: 3717:    { "executemany",   Cursor_executemany,           METH_VARARGS,                  s_Cursor_executemany_doc },
    #####: 3718:    { "fetchone",      Cursor_fetchone,              METH_NOARGS,                   s_Cursor_fetchone_doc },
        -: 3719:    /*
    #####: 3720:        fetchmany does not have *args, but the flag is required for kwargs to function properly.
        -: 3721:        See https://bugs.python.org/issue15657.
    #####: 3722:    */
branch  0 never executed
branch  1 never executed
    #####: 3723:    { "fetchmany",     (PyCFunction)Cursor_fetchmany, METH_VARARGS | METH_KEYWORDS, s_Cursor_fetchmany_doc },
        -: 3724:    { "fetchall",      Cursor_fetchall,               METH_NOARGS,                  s_Cursor_fetchall_doc },
        -: 3725:    { "nextset",       Cursor_nextset,                METH_NOARGS,                  s_Cursor_nextset_doc },
        -: 3726:    { "setinputsizes", Cursor_setinputsizes,          METH_VARARGS,                 s_Cursor_setinputsizes_doc },
    #####: 3727:    { "setoutputsize", Cursor_setoutputsize,          METH_VARARGS,                 s_Cursor_setoutputsize_doc },
call    0 never executed
        -: 3728:
        -: 3729:    /*
        -: 3730:        DB API-2.0 extensions. See
    #####: 3731:        https://www.python.org/dev/peps/pep-0249/#optional-db-api-extensions
        -: 3732:    */
        -: 3733:    { "next",          Cursor_next,                  METH_NOARGS,                   s_Cursor_next_doc },
        -: 3734:
        -: 3735:    /* Non-DB API 2.0 methods. */
        -: 3736:    { "__enter__",     Cursor___enter__,             METH_NOARGS,                   s_Cursor___enter___doc },
        -: 3737:    { "__exit__",      Cursor___exit__,              METH_VARARGS,                  s_Cursor___exit___doc },
        -: 3738:    { NULL,            NULL,                         0,                             NULL }
        -: 3739:};
        -: 3740:
        -: 3741:#if defined(__GNUC__) && (__GNUC__ > 7)
        -: 3742:#  pragma GCC diagnostic pop
        -: 3743:#endif
        -: 3744:
        -: 3745:static PyObject* Cursor_iter(PyObject* self)
        -: 3746:{
        -: 3747:    if (0 != warn_extension_used("cursor.__iter__()"))
        -: 3748:    {
        -: 3749:        return NULL;
        -: 3750:    }
        -: 3751:    Py_INCREF(self);
        -: 3752:    return self;
        -: 3753:}
        -: 3754:
        -: 3755:static PyObject* Cursor_iternext(PyObject* self)
        -: 3756:{
        -: 3757:    return Cursor_next_internal(self, NULL);
        -: 3758:}
        -: 3759:
        -: 3760:PyObject* Cursor_create(struct Connection* connection, enum ParamStyle paramstyle)
        -: 3761:{
        -: 3762:    struct Cursor* cursor = PyObject_New(struct Cursor, &CursorType);
        -: 3763:    if (NULL != cursor)
        -: 3764:    {
        -: 3765:        memset((char*)cursor + offsetof(struct Cursor, connection), 0,
        -: 3766:               (sizeof(struct Cursor) - offsetof(struct Cursor, connection)));
        -: 3767:
        -: 3768:        /*
        -: 3769:            Defaults the arraysize to 1, per
        -: 3770:            https://www.python.org/dev/peps/pep-0249/#arraysize
        -: 3771:        */
        -: 3772:        cursor->arraysize = 1;
        -: 3773:
        -: 3774:        cursor->paramstyle = paramstyle;
        -: 3775:
        -: 3776:        Py_INCREF((PyObject*)connection);
        -: 3777:        cursor->connection = connection;
        -: 3778:    }
        -: 3779:    else
        -: 3780:    {
        -: 3781:        PyErr_NoMemory();
        -: 3782:    }
        -: 3783:
        -: 3784:
        -: 3785:    return (PyObject*)cursor;
        -: 3786:}
        -: 3787:
        -: 3788:
        -: 3789:static PyObject* Cursor_repr(PyObject* self)
        -: 3790:{
        -: 3791:    struct Cursor* cursor = (struct Cursor*)self;
        -: 3792:    if (!cursor->connection)
        -: 3793:    {
        -: 3794:        return PyUnicode_FromString("<k_ctds.Cursor (closed)>");
        -: 3795:    }
        -: 3796:    else if (cursor->description)
        -: 3797:    {
        -: 3798:        return PyUnicode_FromFormat(
        -: 3799:            "<k_ctds.Cursor (open, %zd columns)>",
        -: 3800:            (Py_ssize_t)cursor->description->ncolumns
function CursorType_init called 0 returned 0% blocks executed 0%
    #####: 3801:        );
        -: 3802:    }
    #####: 3803:    else
        -: 3804:    {
    #####: 3805:        return PyUnicode_FromString("<k_ctds.Cursor (open)>");
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3806:    }
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3807:}
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3808:
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3809:#pragma GCC diagnostic push
        -: 3810:#pragma GCC diagnostic ignored "-Wmissing-field-initializers"
        -: 3811:PyTypeObject CursorType = {
        -: 3812:    PyVarObject_HEAD_INIT(NULL, 0)
        -: 3813:    "k_ctds.Cursor",                /* tp_name */
        -: 3814:    sizeof(struct Cursor),        /* tp_basicsize */
        -: 3815:    0,                            /* tp_itemsize */
        -: 3816:    Cursor_dealloc,               /* tp_dealloc */
        -: 3817:#if PY_VERSION_HEX >= 0x03080000
        -: 3818:    0,                            /* tp_vectorcall_offset */
        -: 3819:#else
        -: 3820:    NULL,                         /* tp_print */
        -: 3821:#endif /* if PY_VERSION_HEX >= 0x03080000 */
        -: 3822:    NULL,                         /* tp_getattr */
        -: 3823:    NULL,                         /* tp_setattr */
        -: 3824:    NULL,                         /* tp_reserved */
        -: 3825:    Cursor_repr,                  /* tp_repr */
        -: 3826:    NULL,                         /* tp_as_number */
        -: 3827:    NULL,                         /* tp_as_sequence */
        -: 3828:    NULL,                         /* tp_as_mapping */
        -: 3829:    NULL,                         /* tp_hash */
        -: 3830:    NULL,                         /* tp_call */
        -: 3831:    NULL,                         /* tp_str */
        -: 3832:    NULL,                         /* tp_getattro */
        -: 3833:    NULL,                         /* tp_setattro */
        -: 3834:    NULL,                         /* tp_as_buffer */
        -: 3835:    Py_TPFLAGS_DEFAULT,           /* tp_flags */
        -: 3836:    s_tds_Cursor_doc,             /* tp_doc */
        -: 3837:    NULL,                         /* tp_traverse */
        -: 3838:    NULL,                         /* tp_clear */
        -: 3839:    NULL,                         /* tp_richcompare */
        -: 3840:    0,                            /* tp_weaklistoffset */
        -: 3841:    Cursor_iter,                  /* tp_iter */
        -: 3842:    Cursor_iternext,              /* tp_iternext */
        -: 3843:    Cursor_methods,               /* tp_methods */
        -: 3844:    NULL,                         /* tp_members */
        -: 3845:    Cursor_getset,                /* tp_getset */
        -: 3846:    NULL,                         /* tp_base */
        -: 3847:    NULL,                         /* tp_dict */
        -: 3848:    NULL,                         /* tp_descr_get */
        -: 3849:    NULL,                         /* tp_descr_set */
        -: 3850:    0,                            /* tp_dictoffset */
        -: 3851:    NULL,                         /* tp_init */
        -: 3852:    NULL,                         /* tp_alloc */
        -: 3853:    NULL,                         /* tp_new */
        -: 3854:    NULL,                         /* tp_free */
        -: 3855:    NULL,                         /* tp_is_gc */
        -: 3856:    NULL,                         /* tp_bases */
        -: 3857:    NULL,                         /* tp_mro */
        -: 3858:    NULL,                         /* tp_cache */
        -: 3859:    NULL,                         /* tp_subclasses */
        -: 3860:    NULL,                         /* tp_weaklist */
        -: 3861:    NULL,                         /* tp_del */
        -: 3862:    0,                            /* tp_version_tag */
        -: 3863:#if PY_VERSION_HEX >= 0x03040000
        -: 3864:    NULL,                         /* tp_finalize */
        -: 3865:#endif /* if PY_VERSION_HEX >= 0x03040000 */
        -: 3866:#if PY_VERSION_HEX >= 0x03080000
        -: 3867:    NULL,                         /* tp_vectorcall */
        -: 3868:#  if PY_VERSION_HEX < 0x03090000
        -: 3869:    NULL,                         /* tp_print */
        -: 3870:#  endif /* if PY_VERSION_HEX < 0x03090000 */
        -: 3871:#endif /* if PY_VERSION_HEX >= 0x03080000 */
        -: 3872:};
        -: 3873:#pragma GCC diagnostic pop
        -: 3874:
        -: 3875:PyTypeObject* CursorType_init(void)
        -: 3876:{
        -: 3877:    do
        -: 3878:    {
        -: 3879:        if (0 != Description_init()) break;
        -: 3880:        if (0 != PyType_Ready(&RowType)) break;
        -: 3881:        if (0 != PyType_Ready(&RowListType)) break;
        -: 3882:        if (0 != PyType_Ready(&CursorType)) break;
        -: 3883:        return &CursorType;
        -: 3884:    } while (0);
        -: 3885:
        -: 3886:    return NULL;
        -: 3887:}
